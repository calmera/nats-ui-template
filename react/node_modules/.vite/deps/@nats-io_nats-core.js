import {
  require_mod
} from "./chunk-4RAA3ADM.js";
import {
  __commonJS
} from "./chunk-7D4SUZUM.js";

// node_modules/@nats-io/nats-core/lib/encoders.js
var require_encoders = __commonJS({
  "node_modules/@nats-io/nats-core/lib/encoders.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.TD = exports.TE = exports.Empty = void 0;
    exports.encode = encode;
    exports.decode = decode;
    exports.Empty = new Uint8Array(0);
    exports.TE = new TextEncoder();
    exports.TD = new TextDecoder();
    function concat(...bufs) {
      let max = 0;
      for (let i = 0; i < bufs.length; i++) {
        max += bufs[i].length;
      }
      const out = new Uint8Array(max);
      let index = 0;
      for (let i = 0; i < bufs.length; i++) {
        out.set(bufs[i], index);
        index += bufs[i].length;
      }
      return out;
    }
    function encode(...a) {
      const bufs = [];
      for (let i = 0; i < a.length; i++) {
        bufs.push(exports.TE.encode(a[i]));
      }
      if (bufs.length === 0) {
        return exports.Empty;
      }
      if (bufs.length === 1) {
        return bufs[0];
      }
      return concat(...bufs);
    }
    function decode(a) {
      if (!a || a.length === 0) {
        return "";
      }
      return exports.TD.decode(a);
    }
  }
});

// node_modules/@nats-io/nats-core/lib/errors.js
var require_errors = __commonJS({
  "node_modules/@nats-io/nats-core/lib/errors.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.errors = exports.PermissionViolationError = exports.NoRespondersError = exports.TimeoutError = exports.RequestError = exports.ProtocolError = exports.ConnectionError = exports.DrainingConnectionError = exports.ClosedConnectionError = exports.AuthorizationError = exports.UserAuthenticationExpiredError = exports.InvalidOperationError = exports.InvalidArgumentError = exports.InvalidSubjectError = void 0;
    var InvalidSubjectError = class extends Error {
      constructor(subject, options) {
        super(`illegal subject: '${subject}'`, options);
        this.name = "InvalidSubjectError";
      }
    };
    exports.InvalidSubjectError = InvalidSubjectError;
    var InvalidArgumentError = class _InvalidArgumentError extends Error {
      constructor(message, options) {
        super(message, options);
        this.name = "InvalidArgumentError";
      }
      static format(property, message, options) {
        if (Array.isArray(message) && message.length > 1) {
          message = message[0];
        }
        if (Array.isArray(property)) {
          property = property.map((n) => `'${n}'`);
          property = property.join(",");
        } else {
          property = `'${property}'`;
        }
        return new _InvalidArgumentError(`${property} ${message}`, options);
      }
    };
    exports.InvalidArgumentError = InvalidArgumentError;
    var InvalidOperationError = class extends Error {
      constructor(message, options) {
        super(message, options);
        this.name = "InvalidOperationError";
      }
    };
    exports.InvalidOperationError = InvalidOperationError;
    var UserAuthenticationExpiredError = class _UserAuthenticationExpiredError extends Error {
      constructor(message, options) {
        super(message, options);
        this.name = "UserAuthenticationExpiredError";
      }
      static parse(s) {
        const ss = s.toLowerCase();
        if (ss.indexOf("user authentication expired") !== -1) {
          return new _UserAuthenticationExpiredError(s);
        }
        return null;
      }
    };
    exports.UserAuthenticationExpiredError = UserAuthenticationExpiredError;
    var AuthorizationError = class _AuthorizationError extends Error {
      constructor(message, options) {
        super(message, options);
        this.name = "AuthorizationError";
      }
      static parse(s) {
        const messages = [
          "authorization violation",
          "account authentication expired",
          "authentication timeout"
        ];
        const ss = s.toLowerCase();
        for (let i = 0; i < messages.length; i++) {
          if (ss.indexOf(messages[i]) !== -1) {
            return new _AuthorizationError(s);
          }
        }
        return null;
      }
    };
    exports.AuthorizationError = AuthorizationError;
    var ClosedConnectionError = class extends Error {
      constructor() {
        super("closed connection");
        this.name = "ClosedConnectionError";
      }
    };
    exports.ClosedConnectionError = ClosedConnectionError;
    var DrainingConnectionError = class extends Error {
      constructor() {
        super("connection draining");
        this.name = "DrainingConnectionError";
      }
    };
    exports.DrainingConnectionError = DrainingConnectionError;
    var ConnectionError = class extends Error {
      constructor(message, options) {
        super(message, options);
        this.name = "ConnectionError";
      }
    };
    exports.ConnectionError = ConnectionError;
    var ProtocolError = class extends Error {
      constructor(message, options) {
        super(message, options);
        this.name = "ProtocolError";
      }
    };
    exports.ProtocolError = ProtocolError;
    var RequestError = class extends Error {
      constructor(message = "", options) {
        super(message, options);
        this.name = "RequestError";
      }
      isNoResponders() {
        return this.cause instanceof NoRespondersError;
      }
    };
    exports.RequestError = RequestError;
    var TimeoutError = class extends Error {
      constructor(options) {
        super("timeout", options);
        this.name = "TimeoutError";
      }
    };
    exports.TimeoutError = TimeoutError;
    var NoRespondersError = class extends Error {
      subject;
      constructor(subject, options) {
        super(`no responders: '${subject}'`, options);
        this.subject = subject;
        this.name = "NoResponders";
      }
    };
    exports.NoRespondersError = NoRespondersError;
    var PermissionViolationError = class _PermissionViolationError extends Error {
      operation;
      subject;
      queue;
      constructor(message, operation, subject, queue, options) {
        super(message, options);
        this.name = "PermissionViolationError";
        this.operation = operation;
        this.subject = subject;
        this.queue = queue;
      }
      static parse(s) {
        const t = s ? s.toLowerCase() : "";
        if (t.indexOf("permissions violation") === -1) {
          return null;
        }
        let operation = "publish";
        let subject = "";
        let queue = void 0;
        const m = s.match(/(Publish|Subscription) to "(\S+)"/);
        if (m) {
          operation = m[1].toLowerCase();
          subject = m[2];
          if (operation === "subscription") {
            const qm = s.match(/using queue "(\S+)"/);
            if (qm) {
              queue = qm[1];
            }
          }
        }
        return new _PermissionViolationError(s, operation, subject, queue);
      }
    };
    exports.PermissionViolationError = PermissionViolationError;
    exports.errors = {
      AuthorizationError,
      ClosedConnectionError,
      ConnectionError,
      DrainingConnectionError,
      InvalidArgumentError,
      InvalidOperationError,
      InvalidSubjectError,
      NoRespondersError,
      PermissionViolationError,
      ProtocolError,
      RequestError,
      TimeoutError,
      UserAuthenticationExpiredError
    };
  }
});

// node_modules/@nats-io/nats-core/lib/util.js
var require_util = __commonJS({
  "node_modules/@nats-io/nats-core/lib/util.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.SimpleMutex = exports.Perf = void 0;
    exports.extend = extend;
    exports.render = render;
    exports.timeout = timeout;
    exports.delay = delay;
    exports.deadline = deadline;
    exports.deferred = deferred;
    exports.debugDeferred = debugDeferred;
    exports.shuffle = shuffle;
    exports.collect = collect;
    exports.jitter = jitter;
    exports.backoff = backoff;
    exports.nanos = nanos;
    exports.millis = millis;
    var encoders_1 = require_encoders();
    var errors_1 = require_errors();
    function extend(a, ...b) {
      for (let i = 0; i < b.length; i++) {
        const o = b[i];
        Object.keys(o).forEach(function(k) {
          a[k] = o[k];
        });
      }
      return a;
    }
    function render(frame) {
      const cr = "␍";
      const lf = "␊";
      return encoders_1.TD.decode(frame).replace(/\n/g, lf).replace(/\r/g, cr);
    }
    function timeout(ms, asyncTraces = true) {
      const err = asyncTraces ? new errors_1.TimeoutError() : null;
      let methods;
      let timer;
      const p = new Promise((_resolve, reject) => {
        const cancel = () => {
          if (timer) {
            clearTimeout(timer);
          }
        };
        methods = { cancel };
        timer = setTimeout(() => {
          if (err === null) {
            reject(new errors_1.TimeoutError());
          } else {
            reject(err);
          }
        }, ms);
      });
      return Object.assign(p, methods);
    }
    function delay(ms = 0) {
      let methods;
      const p = new Promise((resolve) => {
        const timer = setTimeout(() => {
          resolve();
        }, ms);
        const cancel = () => {
          if (timer) {
            clearTimeout(timer);
            resolve();
          }
        };
        methods = { cancel };
      });
      return Object.assign(p, methods);
    }
    async function deadline(p, millis2 = 1e3) {
      const d = deferred();
      const timer = setTimeout(() => {
        d.reject(new errors_1.TimeoutError());
      }, millis2);
      try {
        return await Promise.race([p, d]);
      } finally {
        clearTimeout(timer);
      }
    }
    function deferred() {
      let methods = {};
      const p = new Promise((resolve, reject) => {
        methods = { resolve, reject };
      });
      return Object.assign(p, methods);
    }
    function debugDeferred() {
      let methods = {};
      const p = new Promise((resolve, reject) => {
        methods = {
          resolve: (v) => {
            console.trace("resolve", v);
            resolve(v);
          },
          reject: (err) => {
            console.trace("reject");
            reject(err);
          }
        };
      });
      return Object.assign(p, methods);
    }
    function shuffle(a) {
      for (let i = a.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [a[i], a[j]] = [a[j], a[i]];
      }
      return a;
    }
    async function collect(iter) {
      const buf = [];
      for await (const v of iter) {
        buf.push(v);
      }
      return buf;
    }
    var Perf = class {
      timers;
      measures;
      constructor() {
        this.timers = /* @__PURE__ */ new Map();
        this.measures = /* @__PURE__ */ new Map();
      }
      mark(key) {
        this.timers.set(key, performance.now());
      }
      measure(key, startKey, endKey) {
        const s = this.timers.get(startKey);
        if (s === void 0) {
          throw new Error(`${startKey} is not defined`);
        }
        const e = this.timers.get(endKey);
        if (e === void 0) {
          throw new Error(`${endKey} is not defined`);
        }
        this.measures.set(key, e - s);
      }
      getEntries() {
        const values = [];
        this.measures.forEach((v, k) => {
          values.push({ name: k, duration: v });
        });
        return values;
      }
    };
    exports.Perf = Perf;
    var SimpleMutex = class {
      max;
      current;
      waiting;
      /**
       * @param max number of concurrent operations
       */
      constructor(max = 1) {
        this.max = max;
        this.current = 0;
        this.waiting = [];
      }
      /**
       * Returns a promise that resolves when the mutex is acquired
       */
      lock() {
        this.current++;
        if (this.current <= this.max) {
          return Promise.resolve();
        }
        const d = deferred();
        this.waiting.push(d);
        return d;
      }
      /**
       * Release an acquired mutex - must be called
       */
      unlock() {
        this.current--;
        const d = this.waiting.pop();
        d?.resolve();
      }
    };
    exports.SimpleMutex = SimpleMutex;
    function jitter(n) {
      if (n === 0) {
        return 0;
      }
      return Math.floor(n / 2 + Math.random() * n);
    }
    function backoff(policy = [0, 250, 250, 500, 500, 3e3, 5e3]) {
      if (!Array.isArray(policy)) {
        policy = [0, 250, 250, 500, 500, 3e3, 5e3];
      }
      const max = policy.length - 1;
      return {
        backoff(attempt) {
          return jitter(attempt > max ? policy[max] : policy[attempt]);
        }
      };
    }
    function nanos(millis2) {
      return millis2 * 1e6;
    }
    function millis(ns) {
      return Math.floor(ns / 1e6);
    }
  }
});

// node_modules/@nats-io/nuid/lib/nuid.js
var require_nuid = __commonJS({
  "node_modules/@nats-io/nuid/lib/nuid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nuid = exports.Nuid = void 0;
    var digits = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ";
    var base = 36;
    var preLen = 12;
    var seqLen = 10;
    var maxSeq = 3656158440062976;
    var minInc = 33;
    var maxInc = 333;
    var totalLen = preLen + seqLen;
    function _getRandomValues(a) {
      for (let i = 0; i < a.length; i++) {
        a[i] = Math.floor(Math.random() * 255);
      }
    }
    function fillRandom(a) {
      if (globalThis?.crypto?.getRandomValues) {
        globalThis.crypto.getRandomValues(a);
      } else {
        _getRandomValues(a);
      }
    }
    var Nuid = class {
      /**
       *   @hidden
       */
      buf;
      /**
       *   @hidden
       */
      seq;
      /**
       * @hidden
       */
      inc;
      /**
       * @hidden
       */
      inited;
      constructor() {
        this.buf = new Uint8Array(totalLen);
        this.inited = false;
      }
      /**
       * Initializes a nuid with a crypto random prefix,
       * and pseudo-random sequence and increment. This function
       * is only called if any api on a nuid is called.
       *
       * @ignore
       */
      init() {
        this.inited = true;
        this.setPre();
        this.initSeqAndInc();
        this.fillSeq();
      }
      /**
       * Initializes the pseudo random sequence number and the increment range.
       * @ignore
       */
      initSeqAndInc() {
        this.seq = Math.floor(Math.random() * maxSeq);
        this.inc = Math.floor(Math.random() * (maxInc - minInc) + minInc);
      }
      /**
       * Sets the prefix from crypto random bytes. Converts them to base36.
       *
       * @ignore
       */
      setPre() {
        const cbuf = new Uint8Array(preLen);
        fillRandom(cbuf);
        for (let i = 0; i < preLen; i++) {
          const di = cbuf[i] % base;
          this.buf[i] = digits.charCodeAt(di);
        }
      }
      /**
       * Fills the sequence part of the nuid as base36 from this.seq.
       * @ignore
       */
      fillSeq() {
        let n = this.seq;
        for (let i = totalLen - 1; i >= preLen; i--) {
          this.buf[i] = digits.charCodeAt(n % base);
          n = Math.floor(n / base);
        }
      }
      /**
       * Returns the next nuid.
       */
      next() {
        if (!this.inited) {
          this.init();
        }
        this.seq += this.inc;
        if (this.seq > maxSeq) {
          this.setPre();
          this.initSeqAndInc();
        }
        this.fillSeq();
        return String.fromCharCode.apply(String, this.buf);
      }
      /**
       * Resets the prefix and counter for the nuid. This is typically
       * called automatically from within next() if the current sequence
       * exceeds the resolution of the nuid.
       */
      reset() {
        this.init();
      }
    };
    exports.Nuid = Nuid;
    exports.nuid = new Nuid();
  }
});

// node_modules/@nats-io/nats-core/lib/nuid.js
var require_nuid2 = __commonJS({
  "node_modules/@nats-io/nats-core/lib/nuid.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nuid = exports.Nuid = void 0;
    var nuid_1 = require_nuid();
    Object.defineProperty(exports, "Nuid", { enumerable: true, get: function() {
      return nuid_1.Nuid;
    } });
    Object.defineProperty(exports, "nuid", { enumerable: true, get: function() {
      return nuid_1.nuid;
    } });
  }
});

// node_modules/@nats-io/nats-core/lib/core.js
var require_core = __commonJS({
  "node_modules/@nats-io/nats-core/lib/core.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_HOST = exports.DEFAULT_PORT = exports.Match = void 0;
    exports.syncIterator = syncIterator;
    exports.createInbox = createInbox;
    var nuid_1 = require_nuid2();
    var errors_1 = require_errors();
    exports.Match = {
      // Exact option is case-sensitive
      Exact: "exact",
      // Case-sensitive, but key is transformed to Canonical MIME representation
      CanonicalMIME: "canonical",
      // Case-insensitive matches
      IgnoreCase: "insensitive"
    };
    function syncIterator(src) {
      const iter = src[Symbol.asyncIterator]();
      return {
        async next() {
          const m = await iter.next();
          if (m.done) {
            return Promise.resolve(null);
          }
          return Promise.resolve(m.value);
        }
      };
    }
    function createInbox(prefix = "") {
      prefix = prefix || "_INBOX";
      if (typeof prefix !== "string") {
        throw new TypeError("prefix must be a string");
      }
      prefix.split(".").forEach((v) => {
        if (v === "*" || v === ">") {
          throw errors_1.InvalidArgumentError.format("prefix", `cannot have wildcards ('${prefix}')`);
        }
      });
      return `${prefix}.${nuid_1.nuid.next()}`;
    }
    exports.DEFAULT_PORT = 4222;
    exports.DEFAULT_HOST = "127.0.0.1";
  }
});

// node_modules/@nats-io/nats-core/lib/databuffer.js
var require_databuffer = __commonJS({
  "node_modules/@nats-io/nats-core/lib/databuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DataBuffer = void 0;
    var encoders_1 = require_encoders();
    var DataBuffer = class {
      buffers;
      byteLength;
      constructor() {
        this.buffers = [];
        this.byteLength = 0;
      }
      static concat(...bufs) {
        let max = 0;
        for (let i = 0; i < bufs.length; i++) {
          max += bufs[i].length;
        }
        const out = new Uint8Array(max);
        let index = 0;
        for (let i = 0; i < bufs.length; i++) {
          out.set(bufs[i], index);
          index += bufs[i].length;
        }
        return out;
      }
      static fromAscii(m) {
        if (!m) {
          m = "";
        }
        return encoders_1.TE.encode(m);
      }
      static toAscii(a) {
        return encoders_1.TD.decode(a);
      }
      reset() {
        this.buffers.length = 0;
        this.byteLength = 0;
      }
      pack() {
        if (this.buffers.length > 1) {
          const v = new Uint8Array(this.byteLength);
          let index = 0;
          for (let i = 0; i < this.buffers.length; i++) {
            v.set(this.buffers[i], index);
            index += this.buffers[i].length;
          }
          this.buffers.length = 0;
          this.buffers.push(v);
        }
      }
      shift() {
        if (this.buffers.length) {
          const a = this.buffers.shift();
          if (a) {
            this.byteLength -= a.length;
            return a;
          }
        }
        return new Uint8Array(0);
      }
      drain(n) {
        if (this.buffers.length) {
          this.pack();
          const v = this.buffers.pop();
          if (v) {
            const max = this.byteLength;
            if (n === void 0 || n > max) {
              n = max;
            }
            const d = v.subarray(0, n);
            if (max > n) {
              this.buffers.push(v.subarray(n));
            }
            this.byteLength = max - n;
            return d;
          }
        }
        return new Uint8Array(0);
      }
      fill(a, ...bufs) {
        if (a) {
          this.buffers.push(a);
          this.byteLength += a.length;
        }
        for (let i = 0; i < bufs.length; i++) {
          if (bufs[i] && bufs[i].length) {
            this.buffers.push(bufs[i]);
            this.byteLength += bufs[i].length;
          }
        }
      }
      peek() {
        if (this.buffers.length) {
          this.pack();
          return this.buffers[0];
        }
        return new Uint8Array(0);
      }
      size() {
        return this.byteLength;
      }
      length() {
        return this.buffers.length;
      }
    };
    exports.DataBuffer = DataBuffer;
  }
});

// node_modules/@nats-io/nats-core/lib/transport.js
var require_transport = __commonJS({
  "node_modules/@nats-io/nats-core/lib/transport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.LF = exports.CR = exports.CRLF = exports.CR_LF_LEN = exports.CR_LF = void 0;
    exports.setTransportFactory = setTransportFactory;
    exports.defaultPort = defaultPort;
    exports.getUrlParseFn = getUrlParseFn;
    exports.newTransport = newTransport;
    exports.getResolveFn = getResolveFn;
    exports.protoLen = protoLen;
    exports.extractProtocolMessage = extractProtocolMessage;
    var encoders_1 = require_encoders();
    var core_1 = require_core();
    var databuffer_1 = require_databuffer();
    var transportConfig;
    function setTransportFactory(config) {
      transportConfig = config;
    }
    function defaultPort() {
      return transportConfig !== void 0 && transportConfig.defaultPort !== void 0 ? transportConfig.defaultPort : core_1.DEFAULT_PORT;
    }
    function getUrlParseFn() {
      return transportConfig !== void 0 && transportConfig.urlParseFn ? transportConfig.urlParseFn : void 0;
    }
    function newTransport() {
      if (!transportConfig || typeof transportConfig.factory !== "function") {
        throw new Error("transport fn is not set");
      }
      return transportConfig.factory();
    }
    function getResolveFn() {
      return transportConfig !== void 0 && transportConfig.dnsResolveFn ? transportConfig.dnsResolveFn : void 0;
    }
    exports.CR_LF = "\r\n";
    exports.CR_LF_LEN = exports.CR_LF.length;
    exports.CRLF = databuffer_1.DataBuffer.fromAscii(exports.CR_LF);
    exports.CR = new Uint8Array(exports.CRLF)[0];
    exports.LF = new Uint8Array(exports.CRLF)[1];
    function protoLen(ba) {
      for (let i = 0; i < ba.length; i++) {
        const n = i + 1;
        if (ba.byteLength > n && ba[i] === exports.CR && ba[n] === exports.LF) {
          return n + 1;
        }
      }
      return 0;
    }
    function extractProtocolMessage(a) {
      const len = protoLen(a);
      if (len > 0) {
        const ba = new Uint8Array(a);
        const out = ba.slice(0, len);
        return encoders_1.TD.decode(out);
      }
      return "";
    }
  }
});

// node_modules/@nats-io/nats-core/lib/ipparser.js
var require_ipparser = __commonJS({
  "node_modules/@nats-io/nats-core/lib/ipparser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ipV4 = ipV4;
    exports.isIP = isIP;
    exports.parseIP = parseIP;
    var IPv4LEN = 4;
    var IPv6LEN = 16;
    var ASCII0 = 48;
    var ASCII9 = 57;
    var ASCIIA = 65;
    var ASCIIF = 70;
    var ASCIIa = 97;
    var ASCIIf = 102;
    var big = 16777215;
    function ipV4(a, b, c, d) {
      const ip = new Uint8Array(IPv6LEN);
      const prefix = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 255, 255];
      prefix.forEach((v, idx) => {
        ip[idx] = v;
      });
      ip[12] = a;
      ip[13] = b;
      ip[14] = c;
      ip[15] = d;
      return ip;
    }
    function isIP(h) {
      return parseIP(h) !== void 0;
    }
    function parseIP(h) {
      for (let i = 0; i < h.length; i++) {
        switch (h[i]) {
          case ".":
            return parseIPv4(h);
          case ":":
            return parseIPv6(h);
        }
      }
      return;
    }
    function parseIPv4(s) {
      const ip = new Uint8Array(IPv4LEN);
      for (let i = 0; i < IPv4LEN; i++) {
        if (s.length === 0) {
          return void 0;
        }
        if (i > 0) {
          if (s[0] !== ".") {
            return void 0;
          }
          s = s.substring(1);
        }
        const { n, c, ok } = dtoi(s);
        if (!ok || n > 255) {
          return void 0;
        }
        s = s.substring(c);
        ip[i] = n;
      }
      return ipV4(ip[0], ip[1], ip[2], ip[3]);
    }
    function parseIPv6(s) {
      const ip = new Uint8Array(IPv6LEN);
      let ellipsis = -1;
      if (s.length >= 2 && s[0] === ":" && s[1] === ":") {
        ellipsis = 0;
        s = s.substring(2);
        if (s.length === 0) {
          return ip;
        }
      }
      let i = 0;
      while (i < IPv6LEN) {
        const { n, c, ok } = xtoi(s);
        if (!ok || n > 65535) {
          return void 0;
        }
        if (c < s.length && s[c] === ".") {
          if (ellipsis < 0 && i != IPv6LEN - IPv4LEN) {
            return void 0;
          }
          if (i + IPv4LEN > IPv6LEN) {
            return void 0;
          }
          const ip4 = parseIPv4(s);
          if (ip4 === void 0) {
            return void 0;
          }
          ip[i] = ip4[12];
          ip[i + 1] = ip4[13];
          ip[i + 2] = ip4[14];
          ip[i + 3] = ip4[15];
          s = "";
          i += IPv4LEN;
          break;
        }
        ip[i] = n >> 8;
        ip[i + 1] = n;
        i += 2;
        s = s.substring(c);
        if (s.length === 0) {
          break;
        }
        if (s[0] !== ":" || s.length == 1) {
          return void 0;
        }
        s = s.substring(1);
        if (s[0] === ":") {
          if (ellipsis >= 0) {
            return void 0;
          }
          ellipsis = i;
          s = s.substring(1);
          if (s.length === 0) {
            break;
          }
        }
      }
      if (s.length !== 0) {
        return void 0;
      }
      if (i < IPv6LEN) {
        if (ellipsis < 0) {
          return void 0;
        }
        const n = IPv6LEN - i;
        for (let j = i - 1; j >= ellipsis; j--) {
          ip[j + n] = ip[j];
        }
        for (let j = ellipsis + n - 1; j >= ellipsis; j--) {
          ip[j] = 0;
        }
      } else if (ellipsis >= 0) {
        return void 0;
      }
      return ip;
    }
    function dtoi(s) {
      let i = 0;
      let n = 0;
      for (i = 0; i < s.length && ASCII0 <= s.charCodeAt(i) && s.charCodeAt(i) <= ASCII9; i++) {
        n = n * 10 + (s.charCodeAt(i) - ASCII0);
        if (n >= big) {
          return { n: big, c: i, ok: false };
        }
      }
      if (i === 0) {
        return { n: 0, c: 0, ok: false };
      }
      return { n, c: i, ok: true };
    }
    function xtoi(s) {
      let n = 0;
      let i = 0;
      for (i = 0; i < s.length; i++) {
        if (ASCII0 <= s.charCodeAt(i) && s.charCodeAt(i) <= ASCII9) {
          n *= 16;
          n += s.charCodeAt(i) - ASCII0;
        } else if (ASCIIa <= s.charCodeAt(i) && s.charCodeAt(i) <= ASCIIf) {
          n *= 16;
          n += s.charCodeAt(i) - ASCIIa + 10;
        } else if (ASCIIA <= s.charCodeAt(i) && s.charCodeAt(i) <= ASCIIF) {
          n *= 16;
          n += s.charCodeAt(i) - ASCIIA + 10;
        } else {
          break;
        }
        if (n >= big) {
          return { n: 0, c: i, ok: false };
        }
      }
      if (i === 0) {
        return { n: 0, c: i, ok: false };
      }
      return { n, c: i, ok: true };
    }
  }
});

// node_modules/@nats-io/nats-core/lib/servers.js
var require_servers = __commonJS({
  "node_modules/@nats-io/nats-core/lib/servers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Servers = exports.ServerImpl = void 0;
    exports.isIPV4OrHostname = isIPV4OrHostname;
    exports.hostPort = hostPort;
    var transport_1 = require_transport();
    var util_1 = require_util();
    var ipparser_1 = require_ipparser();
    var core_1 = require_core();
    function isIPV4OrHostname(hp) {
      if (hp.indexOf("[") !== -1 || hp.indexOf("::") !== -1) {
        return false;
      }
      if (hp.indexOf(".") !== -1) {
        return true;
      }
      if (hp.split(":").length <= 2) {
        return true;
      }
      return false;
    }
    function isIPV6(hp) {
      return !isIPV4OrHostname(hp);
    }
    function filterIpv6MappedToIpv4(hp) {
      const prefix = "::FFFF:";
      const idx = hp.toUpperCase().indexOf(prefix);
      if (idx !== -1 && hp.indexOf(".") !== -1) {
        let ip = hp.substring(idx + prefix.length);
        ip = ip.replace("[", "");
        return ip.replace("]", "");
      }
      return hp;
    }
    function hostPort(u) {
      u = u.trim();
      if (u.match(/^(.*:\/\/)(.*)/m)) {
        u = u.replace(/^(.*:\/\/)(.*)/gm, "$2");
      }
      u = filterIpv6MappedToIpv4(u);
      if (isIPV6(u) && u.indexOf("[") === -1) {
        u = `[${u}]`;
      }
      const op = isIPV6(u) ? u.match(/(]:)(\d+)/) : u.match(/(:)(\d+)/);
      const port = op && op.length === 3 && op[1] && op[2] ? parseInt(op[2]) : core_1.DEFAULT_PORT;
      const protocol = port === 80 ? "https" : "http";
      const url = new URL(`${protocol}://${u}`);
      url.port = `${port}`;
      let hostname = url.hostname;
      if (hostname.charAt(0) === "[") {
        hostname = hostname.substring(1, hostname.length - 1);
      }
      const listen = url.host;
      return { listen, hostname, port };
    }
    var ServerImpl = class _ServerImpl {
      src;
      listen;
      hostname;
      port;
      didConnect;
      reconnects;
      lastConnect;
      gossiped;
      tlsName;
      resolves;
      constructor(u, gossiped = false) {
        this.src = u;
        this.tlsName = "";
        const v = hostPort(u);
        this.listen = v.listen;
        this.hostname = v.hostname;
        this.port = v.port;
        this.didConnect = false;
        this.reconnects = 0;
        this.lastConnect = 0;
        this.gossiped = gossiped;
      }
      toString() {
        return this.listen;
      }
      async resolve(opts) {
        if (!opts.fn || opts.resolve === false) {
          return [this];
        }
        const buf = [];
        if ((0, ipparser_1.isIP)(this.hostname)) {
          return [this];
        } else {
          const ips = await opts.fn(this.hostname);
          if (opts.debug) {
            console.log(`resolve ${this.hostname} = ${ips.join(",")}`);
          }
          for (const ip of ips) {
            const proto = this.port === 80 ? "https" : "http";
            const url = new URL(`${proto}://${isIPV6(ip) ? "[" + ip + "]" : ip}`);
            url.port = `${this.port}`;
            const ss = new _ServerImpl(url.host, false);
            ss.tlsName = this.hostname;
            buf.push(ss);
          }
        }
        if (opts.randomize) {
          (0, util_1.shuffle)(buf);
        }
        this.resolves = buf;
        return buf;
      }
    };
    exports.ServerImpl = ServerImpl;
    var Servers = class {
      firstSelect;
      servers;
      currentServer;
      tlsName;
      randomize;
      constructor(listens = [], opts = {}) {
        this.firstSelect = true;
        this.servers = [];
        this.tlsName = "";
        this.randomize = opts.randomize || false;
        const urlParseFn = (0, transport_1.getUrlParseFn)();
        if (listens) {
          listens.forEach((hp) => {
            hp = urlParseFn ? urlParseFn(hp) : hp;
            this.servers.push(new ServerImpl(hp));
          });
          if (this.randomize) {
            this.servers = (0, util_1.shuffle)(this.servers);
          }
        }
        if (this.servers.length === 0) {
          this.addServer(`${core_1.DEFAULT_HOST}:${(0, transport_1.defaultPort)()}`, false);
        }
        this.currentServer = this.servers[0];
      }
      clear() {
        this.servers.length = 0;
      }
      updateTLSName() {
        const cs = this.getCurrentServer();
        if (!(0, ipparser_1.isIP)(cs.hostname)) {
          this.tlsName = cs.hostname;
          this.servers.forEach((s) => {
            if (s.gossiped) {
              s.tlsName = this.tlsName;
            }
          });
        }
      }
      getCurrentServer() {
        return this.currentServer;
      }
      addServer(u, implicit = false) {
        const urlParseFn = (0, transport_1.getUrlParseFn)();
        u = urlParseFn ? urlParseFn(u) : u;
        const s = new ServerImpl(u, implicit);
        if ((0, ipparser_1.isIP)(s.hostname)) {
          s.tlsName = this.tlsName;
        }
        this.servers.push(s);
      }
      selectServer() {
        if (this.firstSelect) {
          this.firstSelect = false;
          return this.currentServer;
        }
        const t = this.servers.shift();
        if (t) {
          this.servers.push(t);
          this.currentServer = t;
        }
        return t;
      }
      removeCurrentServer() {
        this.removeServer(this.currentServer);
      }
      removeServer(server) {
        if (server) {
          const index = this.servers.indexOf(server);
          this.servers.splice(index, 1);
        }
      }
      length() {
        return this.servers.length;
      }
      next() {
        return this.servers.length ? this.servers[0] : void 0;
      }
      getServers() {
        return this.servers;
      }
      update(info, encrypted) {
        const added = [];
        let deleted = [];
        const urlParseFn = (0, transport_1.getUrlParseFn)();
        const discovered = /* @__PURE__ */ new Map();
        if (info.connect_urls && info.connect_urls.length > 0) {
          info.connect_urls.forEach((hp) => {
            hp = urlParseFn ? urlParseFn(hp, encrypted) : hp;
            const s = new ServerImpl(hp, true);
            discovered.set(hp, s);
          });
        }
        const toDelete = [];
        this.servers.forEach((s, index) => {
          const u = s.listen;
          if (s.gossiped && this.currentServer.listen !== u && discovered.get(u) === void 0) {
            toDelete.push(index);
          }
          discovered.delete(u);
        });
        toDelete.reverse();
        toDelete.forEach((index) => {
          const removed = this.servers.splice(index, 1);
          deleted = deleted.concat(removed[0].listen);
        });
        discovered.forEach((v, k) => {
          this.servers.push(v);
          added.push(k);
        });
        return { added, deleted };
      }
    };
    exports.Servers = Servers;
  }
});

// node_modules/@nats-io/nats-core/lib/queued_iterator.js
var require_queued_iterator = __commonJS({
  "node_modules/@nats-io/nats-core/lib/queued_iterator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.QueuedIteratorImpl = void 0;
    var util_1 = require_util();
    var errors_1 = require_errors();
    var QueuedIteratorImpl = class {
      inflight;
      processed;
      // this is updated by the protocol
      received;
      noIterator;
      iterClosed;
      done;
      signal;
      yields;
      filtered;
      pendingFiltered;
      ctx;
      _data;
      //data is for use by extenders in any way they like
      err;
      time;
      profile;
      yielding;
      didBreak;
      constructor() {
        this.inflight = 0;
        this.filtered = 0;
        this.pendingFiltered = 0;
        this.processed = 0;
        this.received = 0;
        this.noIterator = false;
        this.done = false;
        this.signal = (0, util_1.deferred)();
        this.yields = [];
        this.iterClosed = (0, util_1.deferred)();
        this.time = 0;
        this.yielding = false;
        this.didBreak = false;
        this.profile = false;
      }
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
      push(v) {
        if (this.done) {
          return;
        }
        if (this.didBreak) {
          if (typeof v === "function") {
            const cb = v;
            try {
              cb();
            } catch (_) {
            }
          }
          return;
        }
        if (typeof v === "function") {
          this.pendingFiltered++;
        }
        this.yields.push(v);
        this.signal.resolve();
      }
      async *iterate() {
        if (this.noIterator) {
          throw new errors_1.InvalidOperationError("iterator cannot be used when a callback is registered");
        }
        if (this.yielding) {
          throw new errors_1.InvalidOperationError("iterator is already yielding");
        }
        this.yielding = true;
        try {
          while (true) {
            if (this.yields.length === 0) {
              await this.signal;
            }
            if (this.err) {
              throw this.err;
            }
            const yields = this.yields;
            this.inflight = yields.length;
            this.yields = [];
            for (let i = 0; i < yields.length; i++) {
              if (typeof yields[i] === "function") {
                this.pendingFiltered--;
                const fn = yields[i];
                try {
                  fn();
                } catch (err) {
                  throw err;
                }
                if (this.err) {
                  throw this.err;
                }
                continue;
              }
              this.processed++;
              this.inflight--;
              const start = this.profile ? Date.now() : 0;
              yield yields[i];
              this.time = this.profile ? Date.now() - start : 0;
            }
            if (this.done) {
              break;
            } else if (this.yields.length === 0) {
              yields.length = 0;
              this.yields = yields;
              this.signal = (0, util_1.deferred)();
            }
          }
        } finally {
          this.didBreak = true;
          this.stop();
        }
      }
      stop(err) {
        if (this.done) {
          return;
        }
        this.err = err;
        this.done = true;
        this.signal.resolve();
        this.iterClosed.resolve(err);
      }
      getProcessed() {
        return this.noIterator ? this.received : this.processed;
      }
      getPending() {
        return this.yields.length + this.inflight - this.pendingFiltered;
      }
      getReceived() {
        return this.received - this.filtered;
      }
    };
    exports.QueuedIteratorImpl = QueuedIteratorImpl;
  }
});

// node_modules/@nats-io/nats-core/lib/muxsubscription.js
var require_muxsubscription = __commonJS({
  "node_modules/@nats-io/nats-core/lib/muxsubscription.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MuxSubscription = void 0;
    var core_1 = require_core();
    var errors_1 = require_errors();
    var MuxSubscription = class {
      baseInbox;
      reqs;
      constructor() {
        this.reqs = /* @__PURE__ */ new Map();
      }
      size() {
        return this.reqs.size;
      }
      init(prefix) {
        this.baseInbox = `${(0, core_1.createInbox)(prefix)}.`;
        return this.baseInbox;
      }
      add(r) {
        if (!isNaN(r.received)) {
          r.received = 0;
        }
        this.reqs.set(r.token, r);
      }
      get(token) {
        return this.reqs.get(token);
      }
      cancel(r) {
        this.reqs.delete(r.token);
      }
      getToken(m) {
        const s = m.subject || "";
        if (s.indexOf(this.baseInbox) === 0) {
          return s.substring(this.baseInbox.length);
        }
        return null;
      }
      all() {
        return Array.from(this.reqs.values());
      }
      handleError(isMuxPermissionError, err) {
        if (isMuxPermissionError) {
          this.all().forEach((r) => {
            r.resolver(err, {});
          });
          return true;
        }
        if (err.operation === "publish") {
          const req = this.all().find((s) => {
            return s.requestSubject === err.subject;
          });
          if (req) {
            req.resolver(err, {});
            return true;
          }
        }
        return false;
      }
      dispatcher() {
        return (err, m) => {
          const token = this.getToken(m);
          if (token) {
            const r = this.get(token);
            if (r) {
              if (err === null) {
                err = m?.data?.length === 0 && m.headers?.code === 503 ? new errors_1.NoRespondersError(r.requestSubject) : null;
              }
              r.resolver(err, m);
            }
          }
        };
      }
      close() {
        const err = new errors_1.RequestError("connection closed");
        this.reqs.forEach((req) => {
          req.resolver(err, {});
        });
      }
    };
    exports.MuxSubscription = MuxSubscription;
  }
});

// node_modules/@nats-io/nats-core/lib/heartbeats.js
var require_heartbeats = __commonJS({
  "node_modules/@nats-io/nats-core/lib/heartbeats.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Heartbeat = void 0;
    var util_1 = require_util();
    var Heartbeat = class {
      ph;
      interval;
      maxOut;
      timer;
      pendings;
      constructor(ph, interval, maxOut) {
        this.ph = ph;
        this.interval = interval;
        this.maxOut = maxOut;
        this.pendings = [];
      }
      // api to start the heartbeats, since this can be
      // spuriously called from dial, ensure we don't
      // leak timers
      start() {
        this.cancel();
        this._schedule();
      }
      // api for canceling the heartbeats, if stale is
      // true it will initiate a client disconnect
      cancel(stale) {
        if (this.timer) {
          clearTimeout(this.timer);
          this.timer = void 0;
        }
        this._reset();
        if (stale) {
          this.ph.disconnect();
        }
      }
      _schedule() {
        this.timer = setTimeout(() => {
          this.ph.dispatchStatus({ type: "ping", pendingPings: this.pendings.length + 1 });
          if (this.pendings.length === this.maxOut) {
            this.cancel(true);
            return;
          }
          const ping = (0, util_1.deferred)();
          this.ph.flush(ping).then(() => {
            this._reset();
          }).catch(() => {
            this.cancel();
          });
          this.pendings.push(ping);
          this._schedule();
        }, this.interval);
      }
      _reset() {
        this.pendings = this.pendings.filter((p) => {
          const d = p;
          d.resolve();
          return false;
        });
      }
    };
    exports.Heartbeat = Heartbeat;
  }
});

// node_modules/@nats-io/nats-core/lib/denobuffer.js
var require_denobuffer = __commonJS({
  "node_modules/@nats-io/nats-core/lib/denobuffer.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DenoBuffer = exports.MAX_SIZE = exports.AssertionError = void 0;
    exports.assert = assert;
    exports.concat = concat;
    exports.append = append;
    exports.readAll = readAll;
    exports.writeAll = writeAll;
    var encoders_1 = require_encoders();
    var AssertionError = class extends Error {
      constructor(msg) {
        super(msg);
        this.name = "AssertionError";
      }
    };
    exports.AssertionError = AssertionError;
    function assert(cond, msg = "Assertion failed.") {
      if (!cond) {
        throw new AssertionError(msg);
      }
    }
    var MIN_READ = 32 * 1024;
    exports.MAX_SIZE = 2 ** 32 - 2;
    function copy(src, dst, off = 0) {
      const r = dst.byteLength - off;
      if (src.byteLength > r) {
        src = src.subarray(0, r);
      }
      dst.set(src, off);
      return src.byteLength;
    }
    function concat(origin, b) {
      if (origin === void 0 && b === void 0) {
        return new Uint8Array(0);
      }
      if (origin === void 0) {
        return b;
      }
      if (b === void 0) {
        return origin;
      }
      const output = new Uint8Array(origin.length + b.length);
      output.set(origin, 0);
      output.set(b, origin.length);
      return output;
    }
    function append(origin, b) {
      return concat(origin, Uint8Array.of(b));
    }
    var DenoBuffer = class {
      _buf;
      // contents are the bytes _buf[off : len(_buf)]
      _off;
      // read at _buf[off], write at _buf[_buf.byteLength]
      constructor(ab) {
        this._off = 0;
        if (ab == null) {
          this._buf = new Uint8Array(0);
          return;
        }
        this._buf = new Uint8Array(ab);
      }
      bytes(options = { copy: true }) {
        if (options.copy === false)
          return this._buf.subarray(this._off);
        return this._buf.slice(this._off);
      }
      empty() {
        return this._buf.byteLength <= this._off;
      }
      get length() {
        return this._buf.byteLength - this._off;
      }
      get capacity() {
        return this._buf.buffer.byteLength;
      }
      truncate(n) {
        if (n === 0) {
          this.reset();
          return;
        }
        if (n < 0 || n > this.length) {
          throw Error("bytes.Buffer: truncation out of range");
        }
        this._reslice(this._off + n);
      }
      reset() {
        this._reslice(0);
        this._off = 0;
      }
      _tryGrowByReslice(n) {
        const l = this._buf.byteLength;
        if (n <= this.capacity - l) {
          this._reslice(l + n);
          return l;
        }
        return -1;
      }
      _reslice(len) {
        assert(len <= this._buf.buffer.byteLength);
        this._buf = new Uint8Array(this._buf.buffer, 0, len);
      }
      readByte() {
        const a = new Uint8Array(1);
        if (this.read(a)) {
          return a[0];
        }
        return null;
      }
      read(p) {
        if (this.empty()) {
          this.reset();
          if (p.byteLength === 0) {
            return 0;
          }
          return null;
        }
        const nread = copy(this._buf.subarray(this._off), p);
        this._off += nread;
        return nread;
      }
      writeByte(n) {
        return this.write(Uint8Array.of(n));
      }
      writeString(s) {
        return this.write(encoders_1.TE.encode(s));
      }
      write(p) {
        const m = this._grow(p.byteLength);
        return copy(p, this._buf, m);
      }
      _grow(n) {
        const m = this.length;
        if (m === 0 && this._off !== 0) {
          this.reset();
        }
        const i = this._tryGrowByReslice(n);
        if (i >= 0) {
          return i;
        }
        const c = this.capacity;
        if (n <= Math.floor(c / 2) - m) {
          copy(this._buf.subarray(this._off), this._buf);
        } else if (c + n > exports.MAX_SIZE) {
          throw new Error("The buffer cannot be grown beyond the maximum size.");
        } else {
          const buf = new Uint8Array(Math.min(2 * c + n, exports.MAX_SIZE));
          copy(this._buf.subarray(this._off), buf);
          this._buf = buf;
        }
        this._off = 0;
        this._reslice(Math.min(m + n, exports.MAX_SIZE));
        return m;
      }
      grow(n) {
        if (n < 0) {
          throw Error("Buffer._grow: negative count");
        }
        const m = this._grow(n);
        this._reslice(m);
      }
      readFrom(r) {
        let n = 0;
        const tmp = new Uint8Array(MIN_READ);
        while (true) {
          const shouldGrow = this.capacity - this.length < MIN_READ;
          const buf = shouldGrow ? tmp : new Uint8Array(this._buf.buffer, this.length);
          const nread = r.read(buf);
          if (nread === null) {
            return n;
          }
          if (shouldGrow)
            this.write(buf.subarray(0, nread));
          else
            this._reslice(this.length + nread);
          n += nread;
        }
      }
    };
    exports.DenoBuffer = DenoBuffer;
    function readAll(r) {
      const buf = new DenoBuffer();
      buf.readFrom(r);
      return buf.bytes();
    }
    function writeAll(w, arr) {
      let nwritten = 0;
      while (nwritten < arr.length) {
        nwritten += w.write(arr.subarray(nwritten));
      }
    }
  }
});

// node_modules/@nats-io/nats-core/lib/parser.js
var require_parser = __commonJS({
  "node_modules/@nats-io/nats-core/lib/parser.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.cc = exports.State = exports.Parser = exports.Kind = void 0;
    exports.describe = describe;
    var denobuffer_1 = require_denobuffer();
    var encoders_1 = require_encoders();
    exports.Kind = {
      OK: 0,
      ERR: 1,
      MSG: 2,
      INFO: 3,
      PING: 4,
      PONG: 5
    };
    function describe(e) {
      let ks;
      let data = "";
      switch (e.kind) {
        case exports.Kind.MSG:
          ks = "MSG";
          break;
        case exports.Kind.OK:
          ks = "OK";
          break;
        case exports.Kind.ERR:
          ks = "ERR";
          data = encoders_1.TD.decode(e.data);
          break;
        case exports.Kind.PING:
          ks = "PING";
          break;
        case exports.Kind.PONG:
          ks = "PONG";
          break;
        case exports.Kind.INFO:
          ks = "INFO";
          data = encoders_1.TD.decode(e.data);
      }
      return `${ks}: ${data}`;
    }
    function newMsgArg() {
      const ma = {};
      ma.sid = -1;
      ma.hdr = -1;
      ma.size = -1;
      return ma;
    }
    var ASCII_0 = 48;
    var ASCII_9 = 57;
    var Parser = class {
      dispatcher;
      state;
      as;
      drop;
      hdr;
      ma;
      argBuf;
      msgBuf;
      constructor(dispatcher) {
        this.dispatcher = dispatcher;
        this.state = exports.State.OP_START;
        this.as = 0;
        this.drop = 0;
        this.hdr = 0;
      }
      parse(buf) {
        let i;
        for (i = 0; i < buf.length; i++) {
          const b = buf[i];
          switch (this.state) {
            case exports.State.OP_START:
              switch (b) {
                case exports.cc.M:
                case exports.cc.m:
                  this.state = exports.State.OP_M;
                  this.hdr = -1;
                  this.ma = newMsgArg();
                  break;
                case exports.cc.H:
                case exports.cc.h:
                  this.state = exports.State.OP_H;
                  this.hdr = 0;
                  this.ma = newMsgArg();
                  break;
                case exports.cc.P:
                case exports.cc.p:
                  this.state = exports.State.OP_P;
                  break;
                case exports.cc.PLUS:
                  this.state = exports.State.OP_PLUS;
                  break;
                case exports.cc.MINUS:
                  this.state = exports.State.OP_MINUS;
                  break;
                case exports.cc.I:
                case exports.cc.i:
                  this.state = exports.State.OP_I;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_H:
              switch (b) {
                case exports.cc.M:
                case exports.cc.m:
                  this.state = exports.State.OP_M;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_M:
              switch (b) {
                case exports.cc.S:
                case exports.cc.s:
                  this.state = exports.State.OP_MS;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_MS:
              switch (b) {
                case exports.cc.G:
                case exports.cc.g:
                  this.state = exports.State.OP_MSG;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_MSG:
              switch (b) {
                case exports.cc.SPACE:
                case exports.cc.TAB:
                  this.state = exports.State.OP_MSG_SPC;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_MSG_SPC:
              switch (b) {
                case exports.cc.SPACE:
                case exports.cc.TAB:
                  continue;
                default:
                  this.state = exports.State.MSG_ARG;
                  this.as = i;
              }
              break;
            case exports.State.MSG_ARG:
              switch (b) {
                case exports.cc.CR:
                  this.drop = 1;
                  break;
                case exports.cc.NL: {
                  const arg = this.argBuf ? this.argBuf.bytes() : buf.subarray(this.as, i - this.drop);
                  this.processMsgArgs(arg);
                  this.drop = 0;
                  this.as = i + 1;
                  this.state = exports.State.MSG_PAYLOAD;
                  i = this.as + this.ma.size - 1;
                  break;
                }
                default:
                  if (this.argBuf) {
                    this.argBuf.writeByte(b);
                  }
              }
              break;
            case exports.State.MSG_PAYLOAD:
              if (this.msgBuf) {
                if (this.msgBuf.length >= this.ma.size) {
                  const data = this.msgBuf.bytes({ copy: false });
                  this.dispatcher.push({ kind: exports.Kind.MSG, msg: this.ma, data });
                  this.argBuf = void 0;
                  this.msgBuf = void 0;
                  this.state = exports.State.MSG_END;
                } else {
                  let toCopy = this.ma.size - this.msgBuf.length;
                  const avail = buf.length - i;
                  if (avail < toCopy) {
                    toCopy = avail;
                  }
                  if (toCopy > 0) {
                    this.msgBuf.write(buf.subarray(i, i + toCopy));
                    i = i + toCopy - 1;
                  } else {
                    this.msgBuf.writeByte(b);
                  }
                }
              } else if (i - this.as >= this.ma.size) {
                this.dispatcher.push({ kind: exports.Kind.MSG, msg: this.ma, data: buf.subarray(this.as, i) });
                this.argBuf = void 0;
                this.msgBuf = void 0;
                this.state = exports.State.MSG_END;
              }
              break;
            case exports.State.MSG_END:
              switch (b) {
                case exports.cc.NL:
                  this.drop = 0;
                  this.as = i + 1;
                  this.state = exports.State.OP_START;
                  break;
                default:
                  continue;
              }
              break;
            case exports.State.OP_PLUS:
              switch (b) {
                case exports.cc.O:
                case exports.cc.o:
                  this.state = exports.State.OP_PLUS_O;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_PLUS_O:
              switch (b) {
                case exports.cc.K:
                case exports.cc.k:
                  this.state = exports.State.OP_PLUS_OK;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_PLUS_OK:
              switch (b) {
                case exports.cc.NL:
                  this.dispatcher.push({ kind: exports.Kind.OK });
                  this.drop = 0;
                  this.state = exports.State.OP_START;
                  break;
              }
              break;
            case exports.State.OP_MINUS:
              switch (b) {
                case exports.cc.E:
                case exports.cc.e:
                  this.state = exports.State.OP_MINUS_E;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_MINUS_E:
              switch (b) {
                case exports.cc.R:
                case exports.cc.r:
                  this.state = exports.State.OP_MINUS_ER;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_MINUS_ER:
              switch (b) {
                case exports.cc.R:
                case exports.cc.r:
                  this.state = exports.State.OP_MINUS_ERR;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_MINUS_ERR:
              switch (b) {
                case exports.cc.SPACE:
                case exports.cc.TAB:
                  this.state = exports.State.OP_MINUS_ERR_SPC;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_MINUS_ERR_SPC:
              switch (b) {
                case exports.cc.SPACE:
                case exports.cc.TAB:
                  continue;
                default:
                  this.state = exports.State.MINUS_ERR_ARG;
                  this.as = i;
              }
              break;
            case exports.State.MINUS_ERR_ARG:
              switch (b) {
                case exports.cc.CR:
                  this.drop = 1;
                  break;
                case exports.cc.NL: {
                  let arg;
                  if (this.argBuf) {
                    arg = this.argBuf.bytes();
                    this.argBuf = void 0;
                  } else {
                    arg = buf.subarray(this.as, i - this.drop);
                  }
                  this.dispatcher.push({ kind: exports.Kind.ERR, data: arg });
                  this.drop = 0;
                  this.as = i + 1;
                  this.state = exports.State.OP_START;
                  break;
                }
                default:
                  if (this.argBuf) {
                    this.argBuf.write(Uint8Array.of(b));
                  }
              }
              break;
            case exports.State.OP_P:
              switch (b) {
                case exports.cc.I:
                case exports.cc.i:
                  this.state = exports.State.OP_PI;
                  break;
                case exports.cc.O:
                case exports.cc.o:
                  this.state = exports.State.OP_PO;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_PO:
              switch (b) {
                case exports.cc.N:
                case exports.cc.n:
                  this.state = exports.State.OP_PON;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_PON:
              switch (b) {
                case exports.cc.G:
                case exports.cc.g:
                  this.state = exports.State.OP_PONG;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_PONG:
              switch (b) {
                case exports.cc.NL:
                  this.dispatcher.push({ kind: exports.Kind.PONG });
                  this.drop = 0;
                  this.state = exports.State.OP_START;
                  break;
              }
              break;
            case exports.State.OP_PI:
              switch (b) {
                case exports.cc.N:
                case exports.cc.n:
                  this.state = exports.State.OP_PIN;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_PIN:
              switch (b) {
                case exports.cc.G:
                case exports.cc.g:
                  this.state = exports.State.OP_PING;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_PING:
              switch (b) {
                case exports.cc.NL:
                  this.dispatcher.push({ kind: exports.Kind.PING });
                  this.drop = 0;
                  this.state = exports.State.OP_START;
                  break;
              }
              break;
            case exports.State.OP_I:
              switch (b) {
                case exports.cc.N:
                case exports.cc.n:
                  this.state = exports.State.OP_IN;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_IN:
              switch (b) {
                case exports.cc.F:
                case exports.cc.f:
                  this.state = exports.State.OP_INF;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_INF:
              switch (b) {
                case exports.cc.O:
                case exports.cc.o:
                  this.state = exports.State.OP_INFO;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_INFO:
              switch (b) {
                case exports.cc.SPACE:
                case exports.cc.TAB:
                  this.state = exports.State.OP_INFO_SPC;
                  break;
                default:
                  throw this.fail(buf.subarray(i));
              }
              break;
            case exports.State.OP_INFO_SPC:
              switch (b) {
                case exports.cc.SPACE:
                case exports.cc.TAB:
                  continue;
                default:
                  this.state = exports.State.INFO_ARG;
                  this.as = i;
              }
              break;
            case exports.State.INFO_ARG:
              switch (b) {
                case exports.cc.CR:
                  this.drop = 1;
                  break;
                case exports.cc.NL: {
                  let arg;
                  if (this.argBuf) {
                    arg = this.argBuf.bytes();
                    this.argBuf = void 0;
                  } else {
                    arg = buf.subarray(this.as, i - this.drop);
                  }
                  this.dispatcher.push({ kind: exports.Kind.INFO, data: arg });
                  this.drop = 0;
                  this.as = i + 1;
                  this.state = exports.State.OP_START;
                  break;
                }
                default:
                  if (this.argBuf) {
                    this.argBuf.writeByte(b);
                  }
              }
              break;
            default:
              throw this.fail(buf.subarray(i));
          }
        }
        if ((this.state === exports.State.MSG_ARG || this.state === exports.State.MINUS_ERR_ARG || this.state === exports.State.INFO_ARG) && !this.argBuf) {
          this.argBuf = new denobuffer_1.DenoBuffer(buf.subarray(this.as, i - this.drop));
        }
        if (this.state === exports.State.MSG_PAYLOAD && !this.msgBuf) {
          if (!this.argBuf) {
            this.cloneMsgArg();
          }
          this.msgBuf = new denobuffer_1.DenoBuffer(buf.subarray(this.as));
        }
      }
      cloneMsgArg() {
        const s = this.ma.subject.length;
        const r = this.ma.reply ? this.ma.reply.length : 0;
        const buf = new Uint8Array(s + r);
        buf.set(this.ma.subject);
        if (this.ma.reply) {
          buf.set(this.ma.reply, s);
        }
        this.argBuf = new denobuffer_1.DenoBuffer(buf);
        this.ma.subject = buf.subarray(0, s);
        if (this.ma.reply) {
          this.ma.reply = buf.subarray(s);
        }
      }
      processMsgArgs(arg) {
        if (this.hdr >= 0) {
          return this.processHeaderMsgArgs(arg);
        }
        const args = [];
        let start = -1;
        for (let i = 0; i < arg.length; i++) {
          const b = arg[i];
          switch (b) {
            case exports.cc.SPACE:
            case exports.cc.TAB:
            case exports.cc.CR:
            case exports.cc.NL:
              if (start >= 0) {
                args.push(arg.subarray(start, i));
                start = -1;
              }
              break;
            default:
              if (start < 0) {
                start = i;
              }
          }
        }
        if (start >= 0) {
          args.push(arg.subarray(start));
        }
        switch (args.length) {
          case 3:
            this.ma.subject = args[0];
            this.ma.sid = this.protoParseInt(args[1]);
            this.ma.reply = void 0;
            this.ma.size = this.protoParseInt(args[2]);
            break;
          case 4:
            this.ma.subject = args[0];
            this.ma.sid = this.protoParseInt(args[1]);
            this.ma.reply = args[2];
            this.ma.size = this.protoParseInt(args[3]);
            break;
          default:
            throw this.fail(arg, "processMsgArgs Parse Error");
        }
        if (this.ma.sid < 0) {
          throw this.fail(arg, "processMsgArgs Bad or Missing Sid Error");
        }
        if (this.ma.size < 0) {
          throw this.fail(arg, "processMsgArgs Bad or Missing Size Error");
        }
      }
      fail(data, label = "") {
        if (!label) {
          label = `parse error [${this.state}]`;
        } else {
          label = `${label} [${this.state}]`;
        }
        return new Error(`${label}: ${encoders_1.TD.decode(data)}`);
      }
      processHeaderMsgArgs(arg) {
        const args = [];
        let start = -1;
        for (let i = 0; i < arg.length; i++) {
          const b = arg[i];
          switch (b) {
            case exports.cc.SPACE:
            case exports.cc.TAB:
            case exports.cc.CR:
            case exports.cc.NL:
              if (start >= 0) {
                args.push(arg.subarray(start, i));
                start = -1;
              }
              break;
            default:
              if (start < 0) {
                start = i;
              }
          }
        }
        if (start >= 0) {
          args.push(arg.subarray(start));
        }
        switch (args.length) {
          case 4:
            this.ma.subject = args[0];
            this.ma.sid = this.protoParseInt(args[1]);
            this.ma.reply = void 0;
            this.ma.hdr = this.protoParseInt(args[2]);
            this.ma.size = this.protoParseInt(args[3]);
            break;
          case 5:
            this.ma.subject = args[0];
            this.ma.sid = this.protoParseInt(args[1]);
            this.ma.reply = args[2];
            this.ma.hdr = this.protoParseInt(args[3]);
            this.ma.size = this.protoParseInt(args[4]);
            break;
          default:
            throw this.fail(arg, "processHeaderMsgArgs Parse Error");
        }
        if (this.ma.sid < 0) {
          throw this.fail(arg, "processHeaderMsgArgs Bad or Missing Sid Error");
        }
        if (this.ma.hdr < 0 || this.ma.hdr > this.ma.size) {
          throw this.fail(arg, "processHeaderMsgArgs Bad or Missing Header Size Error");
        }
        if (this.ma.size < 0) {
          throw this.fail(arg, "processHeaderMsgArgs Bad or Missing Size Error");
        }
      }
      protoParseInt(a) {
        if (a.length === 0) {
          return -1;
        }
        let n = 0;
        for (let i = 0; i < a.length; i++) {
          if (a[i] < ASCII_0 || a[i] > ASCII_9) {
            return -1;
          }
          n = n * 10 + (a[i] - ASCII_0);
        }
        return n;
      }
    };
    exports.Parser = Parser;
    exports.State = {
      OP_START: 0,
      OP_PLUS: 1,
      OP_PLUS_O: 2,
      OP_PLUS_OK: 3,
      OP_MINUS: 4,
      OP_MINUS_E: 5,
      OP_MINUS_ER: 6,
      OP_MINUS_ERR: 7,
      OP_MINUS_ERR_SPC: 8,
      MINUS_ERR_ARG: 9,
      OP_M: 10,
      OP_MS: 11,
      OP_MSG: 12,
      OP_MSG_SPC: 13,
      MSG_ARG: 14,
      MSG_PAYLOAD: 15,
      MSG_END: 16,
      OP_H: 17,
      OP_P: 18,
      OP_PI: 19,
      OP_PIN: 20,
      OP_PING: 21,
      OP_PO: 22,
      OP_PON: 23,
      OP_PONG: 24,
      OP_I: 25,
      OP_IN: 26,
      OP_INF: 27,
      OP_INFO: 28,
      OP_INFO_SPC: 29,
      INFO_ARG: 30
    };
    exports.cc = {
      CR: "\r".charCodeAt(0),
      E: "E".charCodeAt(0),
      e: "e".charCodeAt(0),
      F: "F".charCodeAt(0),
      f: "f".charCodeAt(0),
      G: "G".charCodeAt(0),
      g: "g".charCodeAt(0),
      H: "H".charCodeAt(0),
      h: "h".charCodeAt(0),
      I: "I".charCodeAt(0),
      i: "i".charCodeAt(0),
      K: "K".charCodeAt(0),
      k: "k".charCodeAt(0),
      M: "M".charCodeAt(0),
      m: "m".charCodeAt(0),
      MINUS: "-".charCodeAt(0),
      N: "N".charCodeAt(0),
      n: "n".charCodeAt(0),
      NL: "\n".charCodeAt(0),
      O: "O".charCodeAt(0),
      o: "o".charCodeAt(0),
      P: "P".charCodeAt(0),
      p: "p".charCodeAt(0),
      PLUS: "+".charCodeAt(0),
      R: "R".charCodeAt(0),
      r: "r".charCodeAt(0),
      S: "S".charCodeAt(0),
      s: "s".charCodeAt(0),
      SPACE: " ".charCodeAt(0),
      TAB: "	".charCodeAt(0)
    };
  }
});

// node_modules/@nats-io/nats-core/lib/headers.js
var require_headers = __commonJS({
  "node_modules/@nats-io/nats-core/lib/headers.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgHdrsImpl = void 0;
    exports.canonicalMIMEHeaderKey = canonicalMIMEHeaderKey;
    exports.headers = headers;
    var encoders_1 = require_encoders();
    var core_1 = require_core();
    var errors_1 = require_errors();
    function canonicalMIMEHeaderKey(k) {
      const a = 97;
      const A = 65;
      const Z = 90;
      const z = 122;
      const dash = 45;
      const colon = 58;
      const start = 33;
      const end = 126;
      const toLower = a - A;
      let upper = true;
      const buf = new Array(k.length);
      for (let i = 0; i < k.length; i++) {
        let c = k.charCodeAt(i);
        if (c === colon || c < start || c > end) {
          throw errors_1.InvalidArgumentError.format("header", `'${k[i]}' is not a valid character in a header name`);
        }
        if (upper && a <= c && c <= z) {
          c -= toLower;
        } else if (!upper && A <= c && c <= Z) {
          c += toLower;
        }
        buf[i] = c;
        upper = c == dash;
      }
      return String.fromCharCode(...buf);
    }
    function headers(code = 0, description = "") {
      if (code === 0 && description !== "") {
        throw errors_1.InvalidArgumentError.format("code", "is required");
      } else if (code > 0 && description === "") {
        throw errors_1.InvalidArgumentError.format("description", "is required");
      }
      return new MsgHdrsImpl(code, description);
    }
    var HEADER = "NATS/1.0";
    var MsgHdrsImpl = class _MsgHdrsImpl {
      _code;
      headers;
      _description;
      constructor(code = 0, description = "") {
        this._code = code;
        this._description = description;
        this.headers = /* @__PURE__ */ new Map();
      }
      [Symbol.iterator]() {
        return this.headers.entries();
      }
      size() {
        return this.headers.size;
      }
      equals(mh) {
        if (mh && this.headers.size === mh.headers.size && this._code === mh._code) {
          for (const [k, v] of this.headers) {
            const a = mh.values(k);
            if (v.length !== a.length) {
              return false;
            }
            const vv = [...v].sort();
            const aa = [...a].sort();
            for (let i = 0; i < vv.length; i++) {
              if (vv[i] !== aa[i]) {
                return false;
              }
            }
          }
          return true;
        }
        return false;
      }
      static decode(a) {
        const mh = new _MsgHdrsImpl();
        const s = encoders_1.TD.decode(a);
        const lines = s.split("\r\n");
        const h = lines[0];
        if (h !== HEADER) {
          let str = h.replace(HEADER, "").trim();
          if (str.length > 0) {
            mh._code = parseInt(str, 10);
            if (isNaN(mh._code)) {
              mh._code = 0;
            }
            const scode = mh._code.toString();
            str = str.replace(scode, "");
            mh._description = str.trim();
          }
        }
        if (lines.length >= 1) {
          lines.slice(1).map((s2) => {
            if (s2) {
              const idx = s2.indexOf(":");
              if (idx > -1) {
                const k = s2.slice(0, idx);
                const v = s2.slice(idx + 1).trim();
                mh.append(k, v);
              }
            }
          });
        }
        return mh;
      }
      toString() {
        if (this.headers.size === 0 && this._code === 0) {
          return "";
        }
        let s = HEADER;
        if (this._code > 0 && this._description !== "") {
          s += ` ${this._code} ${this._description}`;
        }
        for (const [k, v] of this.headers) {
          for (let i = 0; i < v.length; i++) {
            s = `${s}\r
${k}: ${v[i]}`;
          }
        }
        return `${s}\r
\r
`;
      }
      encode() {
        return encoders_1.TE.encode(this.toString());
      }
      static validHeaderValue(k) {
        const inv = /[\r\n]/;
        if (inv.test(k)) {
          throw errors_1.InvalidArgumentError.format("header", "values cannot contain \\r or \\n");
        }
        return k.trim();
      }
      keys() {
        const keys = [];
        for (const sk of this.headers.keys()) {
          keys.push(sk);
        }
        return keys;
      }
      findKeys(k, match = core_1.Match.Exact) {
        const keys = this.keys();
        switch (match) {
          case core_1.Match.Exact:
            return keys.filter((v) => {
              return v === k;
            });
          case core_1.Match.CanonicalMIME:
            k = canonicalMIMEHeaderKey(k);
            return keys.filter((v) => {
              return v === k;
            });
          default: {
            const lci = k.toLowerCase();
            return keys.filter((v) => {
              return lci === v.toLowerCase();
            });
          }
        }
      }
      get(k, match = core_1.Match.Exact) {
        const keys = this.findKeys(k, match);
        if (keys.length) {
          const v = this.headers.get(keys[0]);
          if (v) {
            return Array.isArray(v) ? v[0] : v;
          }
        }
        return "";
      }
      last(k, match = core_1.Match.Exact) {
        const keys = this.findKeys(k, match);
        if (keys.length) {
          const v = this.headers.get(keys[0]);
          if (v) {
            return Array.isArray(v) ? v[v.length - 1] : v;
          }
        }
        return "";
      }
      has(k, match = core_1.Match.Exact) {
        return this.findKeys(k, match).length > 0;
      }
      set(k, v, match = core_1.Match.Exact) {
        this.delete(k, match);
        this.append(k, v, match);
      }
      append(k, v, match = core_1.Match.Exact) {
        const ck = canonicalMIMEHeaderKey(k);
        if (match === core_1.Match.CanonicalMIME) {
          k = ck;
        }
        const keys = this.findKeys(k, match);
        k = keys.length > 0 ? keys[0] : k;
        const value = _MsgHdrsImpl.validHeaderValue(v);
        let a = this.headers.get(k);
        if (!a) {
          a = [];
          this.headers.set(k, a);
        }
        a.push(value);
      }
      values(k, match = core_1.Match.Exact) {
        const buf = [];
        const keys = this.findKeys(k, match);
        keys.forEach((v) => {
          const values = this.headers.get(v);
          if (values) {
            buf.push(...values);
          }
        });
        return buf;
      }
      delete(k, match = core_1.Match.Exact) {
        const keys = this.findKeys(k, match);
        keys.forEach((v) => {
          this.headers.delete(v);
        });
      }
      get hasError() {
        return this._code >= 300;
      }
      get status() {
        return `${this._code} ${this._description}`.trim();
      }
      toRecord() {
        const data = {};
        this.keys().forEach((v) => {
          data[v] = this.values(v);
        });
        return data;
      }
      get code() {
        return this._code;
      }
      get description() {
        return this._description;
      }
      static fromRecord(r) {
        const h = new _MsgHdrsImpl();
        for (const k in r) {
          const v = r[k];
          h.headers.set(k, Array.isArray(v) ? v : [`${v}`]);
        }
        return h;
      }
    };
    exports.MsgHdrsImpl = MsgHdrsImpl;
  }
});

// node_modules/@nats-io/nats-core/lib/msg.js
var require_msg = __commonJS({
  "node_modules/@nats-io/nats-core/lib/msg.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.MsgImpl = void 0;
    var headers_1 = require_headers();
    var encoders_1 = require_encoders();
    var MsgImpl = class {
      _headers;
      _msg;
      _rdata;
      _reply;
      _subject;
      publisher;
      constructor(msg, data, publisher) {
        this._msg = msg;
        this._rdata = data;
        this.publisher = publisher;
      }
      get subject() {
        if (this._subject) {
          return this._subject;
        }
        this._subject = encoders_1.TD.decode(this._msg.subject);
        return this._subject;
      }
      get reply() {
        if (this._reply) {
          return this._reply;
        }
        this._reply = encoders_1.TD.decode(this._msg.reply);
        return this._reply;
      }
      get sid() {
        return this._msg.sid;
      }
      get headers() {
        if (this._msg.hdr > -1 && !this._headers) {
          const buf = this._rdata.subarray(0, this._msg.hdr);
          this._headers = headers_1.MsgHdrsImpl.decode(buf);
        }
        return this._headers;
      }
      get data() {
        if (!this._rdata) {
          return new Uint8Array(0);
        }
        return this._msg.hdr > -1 ? this._rdata.subarray(this._msg.hdr) : this._rdata;
      }
      // eslint-ignore-next-line @typescript-eslint/no-explicit-any
      respond(data = encoders_1.Empty, opts) {
        if (this.reply) {
          this.publisher.publish(this.reply, data, opts);
          return true;
        }
        return false;
      }
      size() {
        const subj = this._msg.subject.length;
        const reply = this._msg.reply?.length || 0;
        const payloadAndHeaders = this._msg.size === -1 ? 0 : this._msg.size;
        return subj + reply + payloadAndHeaders;
      }
      json(reviver) {
        return JSON.parse(this.string(), reviver);
      }
      string() {
        return encoders_1.TD.decode(this.data);
      }
      requestInfo() {
        const v = this.headers?.get("Nats-Request-Info");
        if (v) {
          return JSON.parse(v, function(key, value) {
            if ((key === "start" || key === "stop") && value !== "") {
              return new Date(Date.parse(value));
            }
            return value;
          });
        }
        return null;
      }
    };
    exports.MsgImpl = MsgImpl;
  }
});

// node_modules/@nats-io/nats-core/lib/semver.js
var require_semver = __commonJS({
  "node_modules/@nats-io/nats-core/lib/semver.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Features = exports.Feature = void 0;
    exports.parseSemVer = parseSemVer;
    exports.compare = compare;
    function parseSemVer(s = "") {
      const m = s.match(/(\d+).(\d+).(\d+)/);
      if (m) {
        return {
          major: parseInt(m[1]),
          minor: parseInt(m[2]),
          micro: parseInt(m[3])
        };
      }
      throw new Error(`'${s}' is not a semver value`);
    }
    function compare(a, b) {
      if (a.major < b.major)
        return -1;
      if (a.major > b.major)
        return 1;
      if (a.minor < b.minor)
        return -1;
      if (a.minor > b.minor)
        return 1;
      if (a.micro < b.micro)
        return -1;
      if (a.micro > b.micro)
        return 1;
      return 0;
    }
    exports.Feature = {
      JS_KV: "js_kv",
      JS_OBJECTSTORE: "js_objectstore",
      JS_PULL_MAX_BYTES: "js_pull_max_bytes",
      JS_NEW_CONSUMER_CREATE_API: "js_new_consumer_create",
      JS_ALLOW_DIRECT: "js_allow_direct",
      JS_MULTIPLE_CONSUMER_FILTER: "js_multiple_consumer_filter",
      JS_SIMPLIFICATION: "js_simplification",
      JS_STREAM_CONSUMER_METADATA: "js_stream_consumer_metadata",
      JS_CONSUMER_FILTER_SUBJECTS: "js_consumer_filter_subjects",
      JS_STREAM_FIRST_SEQ: "js_stream_first_seq",
      JS_STREAM_SUBJECT_TRANSFORM: "js_stream_subject_transform",
      JS_STREAM_SOURCE_SUBJECT_TRANSFORM: "js_stream_source_subject_transform",
      JS_STREAM_COMPRESSION: "js_stream_compression",
      JS_DEFAULT_CONSUMER_LIMITS: "js_default_consumer_limits",
      JS_BATCH_DIRECT_GET: "js_batch_direct_get",
      JS_PRIORITY_GROUPS: "js_priority_groups"
    };
    var Features = class {
      server;
      features;
      disabled;
      constructor(v) {
        this.features = /* @__PURE__ */ new Map();
        this.disabled = [];
        this.update(v);
      }
      /**
       * Removes all disabled entries
       */
      resetDisabled() {
        this.disabled.length = 0;
        this.update(this.server);
      }
      /**
       * Disables a particular feature.
       * @param f
       */
      disable(f) {
        this.disabled.push(f);
        this.update(this.server);
      }
      isDisabled(f) {
        return this.disabled.indexOf(f) !== -1;
      }
      update(v) {
        if (typeof v === "string") {
          v = parseSemVer(v);
        }
        this.server = v;
        this.set(exports.Feature.JS_KV, "2.6.2");
        this.set(exports.Feature.JS_OBJECTSTORE, "2.6.3");
        this.set(exports.Feature.JS_PULL_MAX_BYTES, "2.8.3");
        this.set(exports.Feature.JS_NEW_CONSUMER_CREATE_API, "2.9.0");
        this.set(exports.Feature.JS_ALLOW_DIRECT, "2.9.0");
        this.set(exports.Feature.JS_MULTIPLE_CONSUMER_FILTER, "2.10.0");
        this.set(exports.Feature.JS_SIMPLIFICATION, "2.9.4");
        this.set(exports.Feature.JS_STREAM_CONSUMER_METADATA, "2.10.0");
        this.set(exports.Feature.JS_CONSUMER_FILTER_SUBJECTS, "2.10.0");
        this.set(exports.Feature.JS_STREAM_FIRST_SEQ, "2.10.0");
        this.set(exports.Feature.JS_STREAM_SUBJECT_TRANSFORM, "2.10.0");
        this.set(exports.Feature.JS_STREAM_SOURCE_SUBJECT_TRANSFORM, "2.10.0");
        this.set(exports.Feature.JS_STREAM_COMPRESSION, "2.10.0");
        this.set(exports.Feature.JS_DEFAULT_CONSUMER_LIMITS, "2.10.0");
        this.set(exports.Feature.JS_BATCH_DIRECT_GET, "2.11.0");
        this.set(exports.Feature.JS_PRIORITY_GROUPS, "2.11.0");
        this.disabled.forEach((f) => {
          this.features.delete(f);
        });
      }
      /**
       * Register a feature that requires a particular server version.
       * @param f
       * @param requires
       */
      set(f, requires) {
        this.features.set(f, {
          min: requires,
          ok: compare(this.server, parseSemVer(requires)) >= 0
        });
      }
      /**
       * Returns whether the feature is available and the min server
       * version that supports it.
       * @param f
       */
      get(f) {
        return this.features.get(f) || { min: "unknown", ok: false };
      }
      /**
       * Returns true if the feature is supported
       * @param f
       */
      supports(f) {
        return this.get(f)?.ok || false;
      }
      /**
       * Returns true if the server is at least the specified version
       * @param v
       */
      require(v) {
        if (typeof v === "string") {
          v = parseSemVer(v);
        }
        return compare(this.server, v) >= 0;
      }
    };
    exports.Features = Features;
  }
});

// node_modules/@nats-io/nats-core/lib/nkeys.js
var require_nkeys = __commonJS({
  "node_modules/@nats-io/nats-core/lib/nkeys.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports && exports.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports && exports.__importStar || /* @__PURE__ */ (function() {
      var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function(o2) {
          var ar = [];
          for (var k in o2) if (Object.prototype.hasOwnProperty.call(o2, k)) ar[ar.length] = k;
          return ar;
        };
        return ownKeys(o);
      };
      return function(mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) {
          for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        }
        __setModuleDefault(result, mod);
        return result;
      };
    })();
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.nkeys = void 0;
    exports.nkeys = __importStar(require_mod());
  }
});

// node_modules/@nats-io/nats-core/lib/authenticator.js
var require_authenticator = __commonJS({
  "node_modules/@nats-io/nats-core/lib/authenticator.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.multiAuthenticator = multiAuthenticator;
    exports.noAuthFn = noAuthFn;
    exports.usernamePasswordAuthenticator = usernamePasswordAuthenticator;
    exports.tokenAuthenticator = tokenAuthenticator;
    exports.nkeyAuthenticator = nkeyAuthenticator;
    exports.jwtAuthenticator = jwtAuthenticator;
    exports.credsAuthenticator = credsAuthenticator;
    var nkeys_1 = require_nkeys();
    var encoders_1 = require_encoders();
    function multiAuthenticator(authenticators) {
      return (nonce) => {
        let auth = {};
        authenticators.forEach((a) => {
          const args = a(nonce) || {};
          auth = Object.assign(auth, args);
        });
        return auth;
      };
    }
    function noAuthFn() {
      return () => {
        return;
      };
    }
    function usernamePasswordAuthenticator(user, pass) {
      return () => {
        const u = typeof user === "function" ? user() : user;
        const p = typeof pass === "function" ? pass() : pass;
        return { user: u, pass: p };
      };
    }
    function tokenAuthenticator(token) {
      return () => {
        const auth_token = typeof token === "function" ? token() : token;
        return { auth_token };
      };
    }
    function nkeyAuthenticator(seed) {
      return (nonce) => {
        const s = typeof seed === "function" ? seed() : seed;
        const kp = s ? nkeys_1.nkeys.fromSeed(s) : void 0;
        const nkey = kp ? kp.getPublicKey() : "";
        const challenge = encoders_1.TE.encode(nonce || "");
        const sigBytes = kp !== void 0 && nonce ? kp.sign(challenge) : void 0;
        const sig = sigBytes ? nkeys_1.nkeys.encode(sigBytes) : "";
        return { nkey, sig };
      };
    }
    function jwtAuthenticator(ajwt, seed) {
      return (nonce) => {
        const jwt = typeof ajwt === "function" ? ajwt() : ajwt;
        const fn = nkeyAuthenticator(seed);
        const { nkey, sig } = fn(nonce);
        return { jwt, nkey, sig };
      };
    }
    function credsAuthenticator(creds) {
      const fn = typeof creds !== "function" ? () => creds : creds;
      const parse = () => {
        const CREDS = /\s*(?:(?:[-]{3,}[^\n]*[-]{3,}\n)(.+)(?:\n\s*[-]{3,}[^\n]*[-]{3,}\n))/ig;
        const s = encoders_1.TD.decode(fn());
        let m = CREDS.exec(s);
        if (!m) {
          throw new Error("unable to parse credentials");
        }
        const jwt = m[1].trim();
        m = CREDS.exec(s);
        if (!m) {
          throw new Error("unable to parse credentials");
        }
        const seed = encoders_1.TE.encode(m[1].trim());
        return { jwt, seed };
      };
      const jwtFn = () => {
        const { jwt } = parse();
        return jwt;
      };
      const nkeyFn = () => {
        const { seed } = parse();
        return seed;
      };
      return jwtAuthenticator(jwtFn, nkeyFn);
    }
  }
});

// node_modules/@nats-io/nats-core/lib/options.js
var require_options = __commonJS({
  "node_modules/@nats-io/nats-core/lib/options.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.DEFAULT_RECONNECT_TIME_WAIT = exports.DEFAULT_MAX_PING_OUT = exports.DEFAULT_PING_INTERVAL = exports.DEFAULT_JITTER_TLS = exports.DEFAULT_JITTER = exports.DEFAULT_MAX_RECONNECT_ATTEMPTS = void 0;
    exports.defaultOptions = defaultOptions;
    exports.hasWsProtocol = hasWsProtocol;
    exports.buildAuthenticator = buildAuthenticator;
    exports.parseOptions = parseOptions;
    exports.checkOptions = checkOptions;
    exports.checkUnsupportedOption = checkUnsupportedOption;
    var util_1 = require_util();
    var transport_1 = require_transport();
    var core_1 = require_core();
    var authenticator_1 = require_authenticator();
    var errors_1 = require_errors();
    exports.DEFAULT_MAX_RECONNECT_ATTEMPTS = 10;
    exports.DEFAULT_JITTER = 100;
    exports.DEFAULT_JITTER_TLS = 1e3;
    exports.DEFAULT_PING_INTERVAL = 2 * 60 * 1e3;
    exports.DEFAULT_MAX_PING_OUT = 2;
    exports.DEFAULT_RECONNECT_TIME_WAIT = 2 * 1e3;
    function defaultOptions() {
      return {
        maxPingOut: exports.DEFAULT_MAX_PING_OUT,
        maxReconnectAttempts: exports.DEFAULT_MAX_RECONNECT_ATTEMPTS,
        noRandomize: false,
        pedantic: false,
        pingInterval: exports.DEFAULT_PING_INTERVAL,
        reconnect: true,
        reconnectJitter: exports.DEFAULT_JITTER,
        reconnectJitterTLS: exports.DEFAULT_JITTER_TLS,
        reconnectTimeWait: exports.DEFAULT_RECONNECT_TIME_WAIT,
        tls: void 0,
        verbose: false,
        waitOnFirstConnect: false,
        ignoreAuthErrorAbort: false
      };
    }
    function hasWsProtocol(opts) {
      if (opts) {
        let { servers } = opts;
        if (typeof servers === "string") {
          servers = [servers];
        }
        if (servers) {
          for (let i = 0; i < servers.length; i++) {
            const s = servers[i].toLowerCase();
            if (s.startsWith("ws://") || s.startsWith("wss://")) {
              return true;
            }
          }
        }
      }
      return false;
    }
    function buildAuthenticator(opts) {
      const buf = [];
      if (typeof opts.authenticator === "function") {
        buf.push(opts.authenticator);
      }
      if (Array.isArray(opts.authenticator)) {
        buf.push(...opts.authenticator);
      }
      if (opts.token) {
        buf.push((0, authenticator_1.tokenAuthenticator)(opts.token));
      }
      if (opts.user) {
        buf.push((0, authenticator_1.usernamePasswordAuthenticator)(opts.user, opts.pass));
      }
      return buf.length === 0 ? (0, authenticator_1.noAuthFn)() : (0, authenticator_1.multiAuthenticator)(buf);
    }
    function parseOptions(opts) {
      const dhp = `${core_1.DEFAULT_HOST}:${(0, transport_1.defaultPort)()}`;
      opts = opts || { servers: [dhp] };
      opts.servers = opts.servers || [];
      if (typeof opts.servers === "string") {
        opts.servers = [opts.servers];
      }
      if (opts.servers.length > 0 && opts.port) {
        throw errors_1.InvalidArgumentError.format(["servers", "port"], "are mutually exclusive");
      }
      if (opts.servers.length === 0 && opts.port) {
        opts.servers = [`${core_1.DEFAULT_HOST}:${opts.port}`];
      }
      if (opts.servers && opts.servers.length === 0) {
        opts.servers = [dhp];
      }
      const options = (0, util_1.extend)(defaultOptions(), opts);
      options.authenticator = buildAuthenticator(options);
      ["reconnectDelayHandler", "authenticator"].forEach((n) => {
        if (options[n] && typeof options[n] !== "function") {
          throw TypeError(`'${n}' must be a function`);
        }
      });
      if (!options.reconnectDelayHandler) {
        options.reconnectDelayHandler = () => {
          let extra = options.tls ? options.reconnectJitterTLS : options.reconnectJitter;
          if (extra) {
            extra++;
            extra = Math.floor(Math.random() * extra);
          }
          return options.reconnectTimeWait + extra;
        };
      }
      if (options.inboxPrefix) {
        (0, core_1.createInbox)(options.inboxPrefix);
      }
      if (options.resolve === void 0) {
        options.resolve = typeof (0, transport_1.getResolveFn)() === "function";
      }
      if (options.resolve) {
        if (typeof (0, transport_1.getResolveFn)() !== "function") {
          throw errors_1.InvalidArgumentError.format("resolve", "is not supported in the current runtime");
        }
      }
      return options;
    }
    function checkOptions(info, options) {
      const { proto, tls_required: tlsRequired, tls_available: tlsAvailable } = info;
      if ((proto === void 0 || proto < 1) && options.noEcho) {
        throw new errors_1.errors.ConnectionError(`server does not support 'noEcho'`);
      }
      const tls = tlsRequired || tlsAvailable || false;
      if (options.tls && !tls) {
        throw new errors_1.errors.ConnectionError(`server does not support 'tls'`);
      }
    }
    function checkUnsupportedOption(prop, v) {
      if (v) {
        throw errors_1.InvalidArgumentError.format(prop, "is not supported");
      }
    }
  }
});

// node_modules/@nats-io/nats-core/lib/protocol.js
var require_protocol = __commonJS({
  "node_modules/@nats-io/nats-core/lib/protocol.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.ProtocolHandler = exports.Subscriptions = exports.SubscriptionImpl = exports.Connect = exports.INFO = void 0;
    var encoders_1 = require_encoders();
    var transport_1 = require_transport();
    var util_1 = require_util();
    var databuffer_1 = require_databuffer();
    var servers_1 = require_servers();
    var queued_iterator_1 = require_queued_iterator();
    var muxsubscription_1 = require_muxsubscription();
    var heartbeats_1 = require_heartbeats();
    var parser_1 = require_parser();
    var msg_1 = require_msg();
    var semver_1 = require_semver();
    var options_1 = require_options();
    var errors_1 = require_errors();
    var FLUSH_THRESHOLD = 1024 * 32;
    exports.INFO = /^INFO\s+([^\r\n]+)\r\n/i;
    var PONG_CMD = (0, encoders_1.encode)("PONG\r\n");
    var PING_CMD = (0, encoders_1.encode)("PING\r\n");
    var Connect = class {
      echo;
      no_responders;
      protocol;
      verbose;
      pedantic;
      jwt;
      nkey;
      sig;
      user;
      pass;
      auth_token;
      tls_required;
      name;
      lang;
      version;
      headers;
      constructor(transport, opts, nonce) {
        this.protocol = 1;
        this.version = transport.version;
        this.lang = transport.lang;
        this.echo = opts.noEcho ? false : void 0;
        this.verbose = opts.verbose;
        this.pedantic = opts.pedantic;
        this.tls_required = opts.tls ? true : void 0;
        this.name = opts.name;
        const creds = (opts && typeof opts.authenticator === "function" ? opts.authenticator(nonce) : {}) || {};
        (0, util_1.extend)(this, creds);
      }
    };
    exports.Connect = Connect;
    var SlowNotifier = class {
      slow;
      cb;
      notified;
      constructor(slow, cb) {
        this.slow = slow;
        this.cb = cb;
        this.notified = false;
      }
      maybeNotify(pending) {
        if (pending <= this.slow) {
          this.notified = false;
        } else {
          if (!this.notified) {
            this.cb(pending);
            this.notified = true;
          }
        }
      }
    };
    var SubscriptionImpl = class extends queued_iterator_1.QueuedIteratorImpl {
      sid;
      queue;
      draining;
      max;
      subject;
      drained;
      protocol;
      timer;
      info;
      cleanupFn;
      closed;
      requestSubject;
      slow;
      constructor(protocol, subject, opts = {}) {
        super();
        (0, util_1.extend)(this, opts);
        this.protocol = protocol;
        this.subject = subject;
        this.draining = false;
        this.noIterator = typeof opts.callback === "function";
        this.closed = (0, util_1.deferred)();
        const asyncTraces = !(protocol.options?.noAsyncTraces || false);
        if (opts.timeout) {
          this.timer = (0, util_1.timeout)(opts.timeout, asyncTraces);
          this.timer.then(() => {
            this.timer = void 0;
          }).catch((err) => {
            this.stop(err);
            if (this.noIterator) {
              this.callback(err, {});
            }
          });
        }
        if (!this.noIterator) {
          this.iterClosed.then((err) => {
            this.closed.resolve(err);
            this.unsubscribe();
          });
        }
      }
      setSlowNotificationFn(slow, fn) {
        this.slow = void 0;
        if (fn) {
          if (this.noIterator) {
            throw new Error("callbacks don't support slow notifications");
          }
          this.slow = new SlowNotifier(slow, fn);
        }
      }
      callback(err, msg) {
        this.cancelTimeout();
        err ? this.stop(err) : this.push(msg);
        if (!err && this.slow) {
          this.slow.maybeNotify(this.getPending());
        }
      }
      close(err) {
        if (!this.isClosed()) {
          this.cancelTimeout();
          const fn = () => {
            this.stop();
            if (this.cleanupFn) {
              try {
                this.cleanupFn(this, this.info);
              } catch (_err) {
              }
            }
            this.closed.resolve(err);
          };
          if (this.noIterator) {
            fn();
          } else {
            this.push(fn);
          }
        }
      }
      unsubscribe(max) {
        this.protocol.unsubscribe(this, max);
      }
      cancelTimeout() {
        if (this.timer) {
          this.timer.cancel();
          this.timer = void 0;
        }
      }
      drain() {
        if (this.protocol.isClosed()) {
          return Promise.reject(new errors_1.errors.ClosedConnectionError());
        }
        if (this.isClosed()) {
          return Promise.reject(new errors_1.errors.InvalidOperationError("subscription is already closed"));
        }
        if (!this.drained) {
          this.draining = true;
          this.protocol.unsub(this);
          this.drained = this.protocol.flush((0, util_1.deferred)()).then(() => {
            this.protocol.subscriptions.cancel(this);
          }).catch(() => {
            this.protocol.subscriptions.cancel(this);
          });
        }
        return this.drained;
      }
      isDraining() {
        return this.draining;
      }
      isClosed() {
        return this.done;
      }
      getSubject() {
        return this.subject;
      }
      getMax() {
        return this.max;
      }
      getID() {
        return this.sid;
      }
    };
    exports.SubscriptionImpl = SubscriptionImpl;
    var Subscriptions = class {
      mux;
      subs;
      sidCounter;
      constructor() {
        this.sidCounter = 0;
        this.mux = null;
        this.subs = /* @__PURE__ */ new Map();
      }
      size() {
        return this.subs.size;
      }
      add(s) {
        this.sidCounter++;
        s.sid = this.sidCounter;
        this.subs.set(s.sid, s);
        return s;
      }
      setMux(s) {
        this.mux = s;
        return s;
      }
      getMux() {
        return this.mux;
      }
      get(sid) {
        return this.subs.get(sid);
      }
      resub(s) {
        this.sidCounter++;
        this.subs.delete(s.sid);
        s.sid = this.sidCounter;
        this.subs.set(s.sid, s);
        return s;
      }
      all() {
        return Array.from(this.subs.values());
      }
      cancel(s) {
        if (s) {
          s.close();
          this.subs.delete(s.sid);
        }
      }
      handleError(err) {
        const subs = this.all();
        let sub;
        if (err.operation === "subscription") {
          sub = subs.find((s) => {
            return s.subject === err.subject && s.queue === err.queue;
          });
        } else if (err.operation === "publish") {
          sub = subs.find((s) => {
            return s.requestSubject === err.subject;
          });
        }
        if (sub) {
          sub.callback(err, {});
          sub.close(err);
          this.subs.delete(sub.sid);
          return sub !== this.mux;
        }
        return false;
      }
      close() {
        this.subs.forEach((sub) => {
          sub.close();
        });
      }
    };
    exports.Subscriptions = Subscriptions;
    var ProtocolHandler = class _ProtocolHandler {
      connected;
      connectedOnce;
      infoReceived;
      info;
      muxSubscriptions;
      options;
      outbound;
      pongs;
      subscriptions;
      transport;
      noMorePublishing;
      connectError;
      publisher;
      _closed;
      closed;
      listeners;
      heartbeats;
      parser;
      outMsgs;
      inMsgs;
      outBytes;
      inBytes;
      pendingLimit;
      lastError;
      abortReconnect;
      whyClosed;
      servers;
      server;
      features;
      connectPromise;
      dialDelay;
      raceTimer;
      constructor(options, publisher) {
        this._closed = false;
        this.connected = false;
        this.connectedOnce = false;
        this.infoReceived = false;
        this.noMorePublishing = false;
        this.abortReconnect = false;
        this.listeners = [];
        this.pendingLimit = FLUSH_THRESHOLD;
        this.outMsgs = 0;
        this.inMsgs = 0;
        this.outBytes = 0;
        this.inBytes = 0;
        this.options = options;
        this.publisher = publisher;
        this.subscriptions = new Subscriptions();
        this.muxSubscriptions = new muxsubscription_1.MuxSubscription();
        this.outbound = new databuffer_1.DataBuffer();
        this.pongs = [];
        this.whyClosed = "";
        this.pendingLimit = options.pendingLimit || this.pendingLimit;
        this.features = new semver_1.Features({ major: 0, minor: 0, micro: 0 });
        this.connectPromise = null;
        this.dialDelay = null;
        const servers = typeof options.servers === "string" ? [options.servers] : options.servers;
        this.servers = new servers_1.Servers(servers, {
          randomize: !options.noRandomize
        });
        this.closed = (0, util_1.deferred)();
        this.parser = new parser_1.Parser(this);
        this.heartbeats = new heartbeats_1.Heartbeat(this, this.options.pingInterval || options_1.DEFAULT_PING_INTERVAL, this.options.maxPingOut || options_1.DEFAULT_MAX_PING_OUT);
      }
      resetOutbound() {
        this.outbound.reset();
        const pongs = this.pongs;
        this.pongs = [];
        const err = new errors_1.errors.RequestError("connection disconnected");
        err.stack = "";
        pongs.forEach((p) => {
          p.reject(err);
        });
        this.parser = new parser_1.Parser(this);
        this.infoReceived = false;
      }
      dispatchStatus(status) {
        this.listeners.forEach((q) => {
          q.push(status);
        });
      }
      prepare() {
        if (this.transport) {
          this.transport.discard();
        }
        this.info = void 0;
        this.resetOutbound();
        const pong = (0, util_1.deferred)();
        pong.catch(() => {
        });
        this.pongs.unshift(pong);
        this.connectError = (err) => {
          pong.reject(err);
        };
        this.transport = (0, transport_1.newTransport)();
        this.transport.closed().then(async (_err) => {
          this.connected = false;
          if (!this.isClosed()) {
            await this.disconnected(this.transport.closeError || this.lastError);
            return;
          }
        });
        return pong;
      }
      disconnect() {
        this.dispatchStatus({ type: "staleConnection" });
        this.transport.disconnect();
      }
      reconnect() {
        if (this.connected) {
          this.dispatchStatus({
            type: "forceReconnect"
          });
          this.transport.disconnect();
        }
        return Promise.resolve();
      }
      async disconnected(err) {
        this.dispatchStatus({
          type: "disconnect",
          server: this.servers.getCurrentServer().toString()
        });
        if (this.options.reconnect) {
          await this.dialLoop().then(() => {
            this.dispatchStatus({
              type: "reconnect",
              server: this.servers.getCurrentServer().toString()
            });
            if (this.lastError instanceof errors_1.errors.UserAuthenticationExpiredError) {
              this.lastError = void 0;
            }
          }).catch((err2) => {
            this.close(err2).catch();
          });
        } else {
          await this.close(err).catch();
        }
      }
      async dial(srv) {
        const pong = this.prepare();
        try {
          this.raceTimer = (0, util_1.timeout)(this.options.timeout || 2e4);
          const cp = this.transport.connect(srv, this.options);
          await Promise.race([cp, this.raceTimer]);
          (async () => {
            try {
              for await (const b of this.transport) {
                this.parser.parse(b);
              }
            } catch (err) {
              console.log("reader closed", err);
            }
          })().then();
        } catch (err) {
          pong.reject(err);
        }
        try {
          await Promise.race([this.raceTimer, pong]);
          this.raceTimer?.cancel();
          this.connected = true;
          this.connectError = void 0;
          this.sendSubscriptions();
          this.connectedOnce = true;
          this.server.didConnect = true;
          this.server.reconnects = 0;
          this.flushPending();
          this.heartbeats.start();
        } catch (err) {
          this.raceTimer?.cancel();
          await this.transport.close(err);
          throw err;
        }
      }
      async _doDial(srv) {
        const { resolve } = this.options;
        const alts = await srv.resolve({
          fn: (0, transport_1.getResolveFn)(),
          debug: this.options.debug,
          randomize: !this.options.noRandomize,
          resolve
        });
        let lastErr = null;
        for (const a of alts) {
          try {
            lastErr = null;
            this.dispatchStatus({ type: "reconnecting" });
            await this.dial(a);
            return;
          } catch (err) {
            lastErr = err;
          }
        }
        throw lastErr;
      }
      dialLoop() {
        if (this.connectPromise === null) {
          this.connectPromise = this.dodialLoop();
          this.connectPromise.then(() => {
          }).catch(() => {
          }).finally(() => {
            this.connectPromise = null;
          });
        }
        return this.connectPromise;
      }
      async dodialLoop() {
        let lastError;
        while (true) {
          if (this._closed) {
            this.servers.clear();
          }
          const wait = this.options.reconnectDelayHandler ? this.options.reconnectDelayHandler() : options_1.DEFAULT_RECONNECT_TIME_WAIT;
          let maxWait = wait;
          const srv = this.selectServer();
          if (!srv || this.abortReconnect) {
            if (lastError) {
              throw lastError;
            } else if (this.lastError) {
              throw this.lastError;
            } else {
              throw new errors_1.errors.ConnectionError("connection refused");
            }
          }
          const now = Date.now();
          if (srv.lastConnect === 0 || srv.lastConnect + wait <= now) {
            srv.lastConnect = Date.now();
            try {
              await this._doDial(srv);
              break;
            } catch (err) {
              lastError = err;
              if (!this.connectedOnce) {
                if (this.options.waitOnFirstConnect) {
                  continue;
                }
                this.servers.removeCurrentServer();
              }
              srv.reconnects++;
              const mra = this.options.maxReconnectAttempts || 0;
              if (mra !== -1 && srv.reconnects >= mra) {
                this.servers.removeCurrentServer();
              }
            }
          } else {
            maxWait = Math.min(maxWait, srv.lastConnect + wait - now);
            this.dialDelay = (0, util_1.delay)(maxWait);
            await this.dialDelay;
          }
        }
      }
      static async connect(options, publisher) {
        const h = new _ProtocolHandler(options, publisher);
        await h.dialLoop();
        return h;
      }
      static toError(s) {
        let err = errors_1.errors.PermissionViolationError.parse(s);
        if (err) {
          return err;
        }
        err = errors_1.errors.UserAuthenticationExpiredError.parse(s);
        if (err) {
          return err;
        }
        err = errors_1.errors.AuthorizationError.parse(s);
        if (err) {
          return err;
        }
        return new errors_1.errors.ProtocolError(s);
      }
      processMsg(msg, data) {
        this.inMsgs++;
        this.inBytes += data.length;
        if (!this.subscriptions.sidCounter) {
          return;
        }
        const sub = this.subscriptions.get(msg.sid);
        if (!sub) {
          return;
        }
        sub.received += 1;
        if (sub.callback) {
          sub.callback(null, new msg_1.MsgImpl(msg, data, this));
        }
        if (sub.max !== void 0 && sub.received >= sub.max) {
          sub.unsubscribe();
        }
      }
      processError(m) {
        let s = (0, encoders_1.decode)(m);
        if (s.startsWith("'") && s.endsWith("'")) {
          s = s.slice(1, s.length - 1);
        }
        const err = _ProtocolHandler.toError(s);
        switch (err.constructor) {
          case errors_1.errors.PermissionViolationError: {
            const pe = err;
            const mux = this.subscriptions.getMux();
            const isMuxPermission = mux ? pe.subject === mux.subject : false;
            this.subscriptions.handleError(pe);
            this.muxSubscriptions.handleError(isMuxPermission, pe);
            if (isMuxPermission) {
              this.subscriptions.setMux(null);
            }
          }
        }
        this.dispatchStatus({ type: "error", error: err });
        this.handleError(err);
      }
      handleError(err) {
        if (err instanceof errors_1.errors.UserAuthenticationExpiredError || err instanceof errors_1.errors.AuthorizationError) {
          this.handleAuthError(err);
        }
        if (!(err instanceof errors_1.errors.PermissionViolationError)) {
          this.lastError = err;
        }
      }
      handleAuthError(err) {
        if ((this.lastError instanceof errors_1.errors.UserAuthenticationExpiredError || this.lastError instanceof errors_1.errors.AuthorizationError) && this.options.ignoreAuthErrorAbort === false) {
          this.abortReconnect = true;
        }
        if (this.connectError) {
          this.connectError(err);
        } else {
          this.disconnect();
        }
      }
      processPing() {
        this.transport.send(PONG_CMD);
      }
      processPong() {
        const cb = this.pongs.shift();
        if (cb) {
          cb.resolve();
        }
      }
      processInfo(m) {
        const info = JSON.parse((0, encoders_1.decode)(m));
        this.info = info;
        const updates = this.options && this.options.ignoreClusterUpdates ? void 0 : this.servers.update(info, this.transport.isEncrypted());
        if (!this.infoReceived) {
          this.features.update((0, semver_1.parseSemVer)(info.version));
          this.infoReceived = true;
          if (this.transport.isEncrypted()) {
            this.servers.updateTLSName();
          }
          const { version, lang } = this.transport;
          try {
            const c = new Connect({ version, lang }, this.options, info.nonce);
            if (info.headers) {
              c.headers = true;
              c.no_responders = true;
            }
            const cs = JSON.stringify(c);
            this.transport.send((0, encoders_1.encode)(`CONNECT ${cs}${transport_1.CR_LF}`));
            this.transport.send(PING_CMD);
          } catch (err) {
            this.close(err).catch();
          }
        }
        if (updates) {
          const { added, deleted } = updates;
          this.dispatchStatus({ type: "update", added, deleted });
        }
        const ldm = info.ldm !== void 0 ? info.ldm : false;
        if (ldm) {
          this.dispatchStatus({
            type: "ldm",
            server: this.servers.getCurrentServer().toString()
          });
        }
      }
      push(e) {
        switch (e.kind) {
          case parser_1.Kind.MSG: {
            const { msg, data } = e;
            this.processMsg(msg, data);
            break;
          }
          case parser_1.Kind.OK:
            break;
          case parser_1.Kind.ERR:
            this.processError(e.data);
            break;
          case parser_1.Kind.PING:
            this.processPing();
            break;
          case parser_1.Kind.PONG:
            this.processPong();
            break;
          case parser_1.Kind.INFO:
            this.processInfo(e.data);
            break;
        }
      }
      sendCommand(cmd, ...payloads) {
        const len = this.outbound.length();
        let buf;
        if (typeof cmd === "string") {
          buf = (0, encoders_1.encode)(cmd);
        } else {
          buf = cmd;
        }
        this.outbound.fill(buf, ...payloads);
        if (len === 0) {
          queueMicrotask(() => {
            this.flushPending();
          });
        } else if (this.outbound.size() >= this.pendingLimit) {
          this.flushPending();
        }
      }
      publish(subject, payload = encoders_1.Empty, options) {
        let data;
        if (payload instanceof Uint8Array) {
          data = payload;
        } else if (typeof payload === "string") {
          data = encoders_1.TE.encode(payload);
        } else {
          throw new TypeError("payload types can be strings or Uint8Array");
        }
        let len = data.length;
        options = options || {};
        options.reply = options.reply || "";
        let headers = encoders_1.Empty;
        let hlen = 0;
        if (options.headers) {
          if (this.info && !this.info.headers) {
            errors_1.InvalidArgumentError.format("headers", "are not available on this server");
          }
          const hdrs = options.headers;
          headers = hdrs.encode();
          hlen = headers.length;
          len = data.length + hlen;
        }
        if (this.info && len > this.info.max_payload) {
          throw errors_1.InvalidArgumentError.format("payload", "max_payload size exceeded");
        }
        this.outBytes += len;
        this.outMsgs++;
        let proto;
        if (options.headers) {
          if (options.reply) {
            proto = `HPUB ${subject} ${options.reply} ${hlen} ${len}\r
`;
          } else {
            proto = `HPUB ${subject} ${hlen} ${len}\r
`;
          }
          this.sendCommand(proto, headers, data, transport_1.CRLF);
        } else {
          if (options.reply) {
            proto = `PUB ${subject} ${options.reply} ${len}\r
`;
          } else {
            proto = `PUB ${subject} ${len}\r
`;
          }
          this.sendCommand(proto, data, transport_1.CRLF);
        }
      }
      request(r) {
        this.initMux();
        this.muxSubscriptions.add(r);
        return r;
      }
      subscribe(s) {
        this.subscriptions.add(s);
        this._subunsub(s);
        return s;
      }
      _sub(s) {
        if (s.queue) {
          this.sendCommand(`SUB ${s.subject} ${s.queue} ${s.sid}\r
`);
        } else {
          this.sendCommand(`SUB ${s.subject} ${s.sid}\r
`);
        }
      }
      _subunsub(s) {
        this._sub(s);
        if (s.max) {
          this.unsubscribe(s, s.max);
        }
        return s;
      }
      unsubscribe(s, max) {
        this.unsub(s, max);
        if (s.max === void 0 || s.received >= s.max) {
          this.subscriptions.cancel(s);
        }
      }
      unsub(s, max) {
        if (!s || this.isClosed()) {
          return;
        }
        if (max) {
          this.sendCommand(`UNSUB ${s.sid} ${max}\r
`);
        } else {
          this.sendCommand(`UNSUB ${s.sid}\r
`);
        }
        s.max = max;
      }
      resub(s, subject) {
        if (!s || this.isClosed()) {
          return;
        }
        this.unsub(s);
        s.subject = subject;
        this.subscriptions.resub(s);
        this._sub(s);
      }
      flush(p) {
        if (!p) {
          p = (0, util_1.deferred)();
        }
        this.pongs.push(p);
        this.outbound.fill(PING_CMD);
        this.flushPending();
        return p;
      }
      sendSubscriptions() {
        const cmds = [];
        this.subscriptions.all().forEach((s) => {
          const sub = s;
          if (sub.queue) {
            cmds.push(`SUB ${sub.subject} ${sub.queue} ${sub.sid}${transport_1.CR_LF}`);
          } else {
            cmds.push(`SUB ${sub.subject} ${sub.sid}${transport_1.CR_LF}`);
          }
        });
        if (cmds.length) {
          this.transport.send((0, encoders_1.encode)(cmds.join("")));
        }
      }
      async close(err) {
        if (this._closed) {
          return;
        }
        this.whyClosed = new Error("close trace").stack || "";
        this.heartbeats.cancel();
        if (this.connectError) {
          this.connectError(err);
          this.connectError = void 0;
        }
        this.muxSubscriptions.close();
        this.subscriptions.close();
        const proms = [];
        for (let i = 0; i < this.listeners.length; i++) {
          const qi = this.listeners[i];
          if (qi) {
            qi.push({ type: "close" });
            qi.stop();
            proms.push(qi.iterClosed);
          }
        }
        if (proms.length) {
          await Promise.all(proms);
        }
        this._closed = true;
        await this.transport.close(err);
        this.raceTimer?.cancel();
        this.dialDelay?.cancel();
        this.closed.resolve(err);
      }
      isClosed() {
        return this._closed;
      }
      async drain() {
        const subs = this.subscriptions.all();
        const promises = [];
        subs.forEach((sub) => {
          promises.push(sub.drain());
        });
        try {
          await Promise.allSettled(promises);
        } catch {
        } finally {
          this.noMorePublishing = true;
          await this.flush();
        }
        return this.close();
      }
      flushPending() {
        if (!this.infoReceived || !this.connected) {
          return;
        }
        if (this.outbound.size()) {
          const d = this.outbound.drain();
          this.transport.send(d);
        }
      }
      initMux() {
        const mux = this.subscriptions.getMux();
        if (!mux) {
          const inbox = this.muxSubscriptions.init(this.options.inboxPrefix);
          const sub = new SubscriptionImpl(this, `${inbox}*`);
          sub.callback = this.muxSubscriptions.dispatcher();
          this.subscriptions.setMux(sub);
          this.subscribe(sub);
        }
      }
      selectServer() {
        const server = this.servers.selectServer();
        if (server === void 0) {
          return void 0;
        }
        this.server = server;
        return this.server;
      }
      getServer() {
        return this.server;
      }
    };
    exports.ProtocolHandler = ProtocolHandler;
  }
});

// node_modules/@nats-io/nats-core/lib/request.js
var require_request = __commonJS({
  "node_modules/@nats-io/nats-core/lib/request.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.RequestOne = exports.RequestMany = exports.BaseRequest = void 0;
    var util_1 = require_util();
    var nuid_1 = require_nuid2();
    var errors_1 = require_errors();
    var BaseRequest = class {
      token;
      received;
      ctx;
      requestSubject;
      mux;
      constructor(mux, requestSubject, asyncTraces = true) {
        this.mux = mux;
        this.requestSubject = requestSubject;
        this.received = 0;
        this.token = nuid_1.nuid.next();
        if (asyncTraces) {
          this.ctx = new errors_1.RequestError();
        }
      }
    };
    exports.BaseRequest = BaseRequest;
    var RequestMany = class extends BaseRequest {
      callback;
      done;
      timer;
      max;
      opts;
      constructor(mux, requestSubject, opts = { maxWait: 1e3 }) {
        super(mux, requestSubject);
        this.opts = opts;
        if (typeof this.opts.callback !== "function") {
          throw new TypeError("callback must be a function");
        }
        this.callback = this.opts.callback;
        this.max = typeof opts.maxMessages === "number" && opts.maxMessages > 0 ? opts.maxMessages : -1;
        this.done = (0, util_1.deferred)();
        this.done.then(() => {
          this.callback(null, null);
        });
        this.timer = setTimeout(() => {
          this.cancel();
        }, opts.maxWait);
      }
      cancel(err) {
        if (err) {
          this.callback(err, null);
        }
        clearTimeout(this.timer);
        this.mux.cancel(this);
        this.done.resolve();
      }
      resolver(err, msg) {
        if (err) {
          if (this.ctx) {
            err.stack += `

${this.ctx.stack}`;
          }
          this.cancel(err);
        } else {
          this.callback(null, msg);
          if (this.opts.strategy === "count") {
            this.max--;
            if (this.max === 0) {
              this.cancel();
            }
          }
          if (this.opts.strategy === "stall") {
            clearTimeout(this.timer);
            this.timer = setTimeout(() => {
              this.cancel();
            }, this.opts.stall || 300);
          }
          if (this.opts.strategy === "sentinel") {
            if (msg && msg.data.length === 0) {
              this.cancel();
            }
          }
        }
      }
    };
    exports.RequestMany = RequestMany;
    var RequestOne = class extends BaseRequest {
      deferred;
      timer;
      constructor(mux, requestSubject, opts = { timeout: 1e3 }, asyncTraces = true) {
        super(mux, requestSubject, asyncTraces);
        this.deferred = (0, util_1.deferred)();
        this.timer = (0, util_1.timeout)(opts.timeout, asyncTraces);
      }
      resolver(err, msg) {
        if (this.timer) {
          this.timer.cancel();
        }
        if (err) {
          if (!(err instanceof errors_1.TimeoutError)) {
            if (this.ctx) {
              this.ctx.message = err.message;
              this.ctx.cause = err;
              err = this.ctx;
            } else {
              err = new errors_1.errors.RequestError(err.message, { cause: err });
            }
          }
          this.deferred.reject(err);
        } else {
          this.deferred.resolve(msg);
        }
        this.cancel();
      }
      cancel(err) {
        if (this.timer) {
          this.timer.cancel();
        }
        this.mux.cancel(this);
        this.deferred.reject(err ? err : new errors_1.RequestError("cancelled"));
      }
    };
    exports.RequestOne = RequestOne;
  }
});

// node_modules/@nats-io/nats-core/lib/nats.js
var require_nats = __commonJS({
  "node_modules/@nats-io/nats-core/lib/nats.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.NatsConnectionImpl = void 0;
    var util_1 = require_util();
    var protocol_1 = require_protocol();
    var encoders_1 = require_encoders();
    var headers_1 = require_headers();
    var semver_1 = require_semver();
    var options_1 = require_options();
    var queued_iterator_1 = require_queued_iterator();
    var request_1 = require_request();
    var core_1 = require_core();
    var errors_1 = require_errors();
    var whitespaceRegex = /[ \n\r\t]/;
    var NatsConnectionImpl = class _NatsConnectionImpl {
      options;
      protocol;
      draining;
      closeListeners;
      constructor(opts) {
        this.draining = false;
        this.options = (0, options_1.parseOptions)(opts);
      }
      static connect(opts = {}) {
        return new Promise((resolve, reject) => {
          const nc = new _NatsConnectionImpl(opts);
          protocol_1.ProtocolHandler.connect(nc.options, nc).then((ph) => {
            nc.protocol = ph;
            resolve(nc);
          }).catch((err) => {
            reject(err);
          });
        });
      }
      closed() {
        return this.protocol.closed;
      }
      async close() {
        await this.protocol.close();
      }
      _check(subject, sub, pub) {
        if (this.isClosed()) {
          throw new errors_1.errors.ClosedConnectionError();
        }
        if (sub && this.isDraining()) {
          throw new errors_1.errors.DrainingConnectionError();
        }
        if (pub && this.protocol.noMorePublishing) {
          throw new errors_1.errors.DrainingConnectionError();
        }
        subject = subject || "";
        if (subject.length === 0 || whitespaceRegex.test(subject)) {
          throw new errors_1.errors.InvalidSubjectError(subject);
        }
      }
      publish(subject, data, options) {
        this._check(subject, false, true);
        if (options?.reply) {
          this._check(options.reply, false, true);
        }
        if (typeof options?.traceOnly === "boolean") {
          const hdrs = options.headers || (0, headers_1.headers)();
          hdrs.set("Nats-Trace-Only", "true");
          options.headers = hdrs;
        }
        if (typeof options?.traceDestination === "string") {
          const hdrs = options.headers || (0, headers_1.headers)();
          hdrs.set("Nats-Trace-Dest", options.traceDestination);
          options.headers = hdrs;
        }
        this.protocol.publish(subject, data, options);
      }
      publishMessage(msg) {
        return this.publish(msg.subject, msg.data, {
          reply: msg.reply,
          headers: msg.headers
        });
      }
      respondMessage(msg) {
        if (msg.reply) {
          this.publish(msg.reply, msg.data, {
            reply: msg.reply,
            headers: msg.headers
          });
          return true;
        }
        return false;
      }
      subscribe(subject, opts = {}) {
        this._check(subject, true, false);
        const sub = new protocol_1.SubscriptionImpl(this.protocol, subject, opts);
        if (typeof opts.callback !== "function" && typeof opts.slow === "number") {
          sub.setSlowNotificationFn(opts.slow, (pending) => {
            this.protocol.dispatchStatus({
              type: "slowConsumer",
              sub,
              pending
            });
          });
        }
        this.protocol.subscribe(sub);
        return sub;
      }
      _resub(s, subject, max) {
        this._check(subject, true, false);
        const si = s;
        si.max = max;
        if (max) {
          si.max = max + si.received;
        }
        this.protocol.resub(si, subject);
      }
      // possibilities are:
      // stop on error or any non-100 status
      // AND:
      // - wait for timer
      // - wait for n messages or timer
      // - wait for unknown messages, done when empty or reset timer expires (with possible alt wait)
      // - wait for unknown messages, done when an empty payload is received or timer expires (with possible alt wait)
      requestMany(subject, data = encoders_1.Empty, opts = { maxWait: 1e3, maxMessages: -1 }) {
        const asyncTraces = !(this.protocol.options.noAsyncTraces || false);
        try {
          this._check(subject, true, true);
        } catch (err) {
          return Promise.reject(err);
        }
        opts.strategy = opts.strategy || "timer";
        opts.maxWait = opts.maxWait || 1e3;
        if (opts.maxWait < 1) {
          return Promise.reject(errors_1.InvalidArgumentError.format("timeout", "must be greater than 0"));
        }
        const qi = new queued_iterator_1.QueuedIteratorImpl();
        function stop(err) {
          qi.push(() => {
            qi.stop(err);
          });
        }
        function callback(err, msg) {
          if (err || msg === null) {
            stop(err === null ? void 0 : err);
          } else {
            qi.push(msg);
          }
        }
        if (opts.noMux) {
          const stack = asyncTraces ? new Error().stack : null;
          let max = typeof opts.maxMessages === "number" && opts.maxMessages > 0 ? opts.maxMessages : -1;
          const sub = this.subscribe((0, core_1.createInbox)(this.options.inboxPrefix), {
            callback: (err, msg) => {
              if (msg?.data?.length === 0 && msg?.headers?.status === "503") {
                err = new errors_1.errors.NoRespondersError(subject);
              }
              if (err) {
                if (stack) {
                  err.stack += `

${stack}`;
                }
                cancel(err);
                return;
              }
              callback(null, msg);
              if (opts.strategy === "count") {
                max--;
                if (max === 0) {
                  cancel();
                }
              }
              if (opts.strategy === "stall") {
                clearTimers();
                timer = setTimeout(() => {
                  cancel();
                }, 300);
              }
              if (opts.strategy === "sentinel") {
                if (msg && msg.data.length === 0) {
                  cancel();
                }
              }
            }
          });
          sub.requestSubject = subject;
          sub.closed.then(() => {
            stop();
          }).catch((err) => {
            qi.stop(err);
          });
          const cancel = (err) => {
            if (err) {
              qi.push(() => {
                throw err;
              });
            }
            clearTimers();
            sub.drain().then(() => {
              stop();
            }).catch((_err) => {
              stop();
            });
          };
          qi.iterClosed.then(() => {
            clearTimers();
            sub?.unsubscribe();
          }).catch((_err) => {
            clearTimers();
            sub?.unsubscribe();
          });
          const { headers, traceDestination, traceOnly } = opts;
          try {
            this.publish(subject, data, {
              reply: sub.getSubject(),
              headers,
              traceDestination,
              traceOnly
            });
          } catch (err) {
            cancel(err);
          }
          let timer = setTimeout(() => {
            cancel();
          }, opts.maxWait);
          const clearTimers = () => {
            if (timer) {
              clearTimeout(timer);
            }
          };
        } else {
          const rmo = opts;
          rmo.callback = callback;
          qi.iterClosed.then(() => {
            r.cancel();
          }).catch((err) => {
            r.cancel(err);
          });
          const r = new request_1.RequestMany(this.protocol.muxSubscriptions, subject, rmo);
          this.protocol.request(r);
          const { headers, traceDestination, traceOnly } = opts;
          try {
            this.publish(subject, data, {
              reply: `${this.protocol.muxSubscriptions.baseInbox}${r.token}`,
              headers,
              traceDestination,
              traceOnly
            });
          } catch (err) {
            r.cancel(err);
          }
        }
        return Promise.resolve(qi);
      }
      request(subject, data, opts = { timeout: 1e3, noMux: false }) {
        try {
          this._check(subject, true, true);
        } catch (err) {
          return Promise.reject(err);
        }
        const asyncTraces = !(this.protocol.options.noAsyncTraces || false);
        opts.timeout = opts.timeout || 1e3;
        if (opts.timeout < 1) {
          return Promise.reject(errors_1.InvalidArgumentError.format("timeout", `must be greater than 0`));
        }
        if (!opts.noMux && opts.reply) {
          return Promise.reject(errors_1.InvalidArgumentError.format(["reply", "noMux"], "are mutually exclusive"));
        }
        if (opts.noMux) {
          const inbox = opts.reply ? opts.reply : (0, core_1.createInbox)(this.options.inboxPrefix);
          const d = (0, util_1.deferred)();
          const errCtx = asyncTraces ? new errors_1.errors.RequestError("") : null;
          const sub = this.subscribe(inbox, {
            max: 1,
            timeout: opts.timeout,
            callback: (err, msg) => {
              if (msg && msg.data?.length === 0 && msg.headers?.code === 503) {
                err = new errors_1.errors.NoRespondersError(subject);
              }
              if (err) {
                if (!(err instanceof errors_1.TimeoutError)) {
                  if (errCtx) {
                    errCtx.message = err.message;
                    errCtx.cause = err;
                    err = errCtx;
                  } else {
                    err = new errors_1.errors.RequestError(err.message, { cause: err });
                  }
                }
                d.reject(err);
                sub.unsubscribe();
              } else {
                d.resolve(msg);
              }
            }
          });
          sub.requestSubject = subject;
          this.protocol.publish(subject, data, {
            reply: inbox,
            headers: opts.headers
          });
          return d;
        } else {
          const r = new request_1.RequestOne(this.protocol.muxSubscriptions, subject, opts, asyncTraces);
          this.protocol.request(r);
          const { headers, traceDestination, traceOnly } = opts;
          try {
            this.publish(subject, data, {
              reply: `${this.protocol.muxSubscriptions.baseInbox}${r.token}`,
              headers,
              traceDestination,
              traceOnly
            });
          } catch (err) {
            r.cancel(err);
          }
          const p = Promise.race([r.timer, r.deferred]);
          p.catch(() => {
            r.cancel();
          });
          return p;
        }
      }
      /** *
       * Flushes to the server. Promise resolves when round-trip completes.
       * @returns {Promise<void>}
       */
      flush() {
        if (this.isClosed()) {
          return Promise.reject(new errors_1.errors.ClosedConnectionError());
        }
        return this.protocol.flush();
      }
      drain() {
        if (this.isClosed()) {
          return Promise.reject(new errors_1.errors.ClosedConnectionError());
        }
        if (this.isDraining()) {
          return Promise.reject(new errors_1.errors.DrainingConnectionError());
        }
        this.draining = true;
        return this.protocol.drain();
      }
      isClosed() {
        return this.protocol.isClosed();
      }
      isDraining() {
        return this.draining;
      }
      getServer() {
        const srv = this.protocol.getServer();
        return srv ? srv.listen : "";
      }
      status() {
        const iter = new queued_iterator_1.QueuedIteratorImpl();
        iter.iterClosed.then(() => {
          const idx = this.protocol.listeners.indexOf(iter);
          if (idx > -1) {
            this.protocol.listeners.splice(idx, 1);
          }
        });
        this.protocol.listeners.push(iter);
        return iter;
      }
      get info() {
        return this.protocol.isClosed() ? void 0 : this.protocol.info;
      }
      async context() {
        const r = await this.request(`$SYS.REQ.USER.INFO`);
        return r.json((key, value) => {
          if (key === "time") {
            return new Date(Date.parse(value));
          }
          return value;
        });
      }
      stats() {
        return {
          inBytes: this.protocol.inBytes,
          outBytes: this.protocol.outBytes,
          inMsgs: this.protocol.inMsgs,
          outMsgs: this.protocol.outMsgs
        };
      }
      getServerVersion() {
        const info = this.info;
        return info ? (0, semver_1.parseSemVer)(info.version) : void 0;
      }
      async rtt() {
        if (this.isClosed()) {
          throw new errors_1.errors.ClosedConnectionError();
        }
        if (!this.protocol.connected) {
          throw new errors_1.errors.RequestError("connection disconnected");
        }
        const start = Date.now();
        await this.flush();
        return Date.now() - start;
      }
      get features() {
        return this.protocol.features;
      }
      reconnect() {
        if (this.isClosed()) {
          return Promise.reject(new errors_1.errors.ClosedConnectionError());
        }
        if (this.isDraining()) {
          return Promise.reject(new errors_1.errors.DrainingConnectionError());
        }
        return this.protocol.reconnect();
      }
      // internal
      addCloseListener(listener) {
        if (this.closeListeners === void 0) {
          this.closeListeners = new CloseListeners(this.closed());
        }
        this.closeListeners.add(listener);
      }
      // internal
      removeCloseListener(listener) {
        if (this.closeListeners) {
          this.closeListeners.remove(listener);
        }
      }
    };
    exports.NatsConnectionImpl = NatsConnectionImpl;
    var CloseListeners = class {
      listeners;
      constructor(closed) {
        this.listeners = [];
        closed.then((err) => {
          this.notify(err);
        });
      }
      add(listener) {
        this.listeners.push(listener);
      }
      remove(listener) {
        this.listeners = this.listeners.filter((l) => l !== listener);
      }
      notify(err) {
        this.listeners.forEach((l) => {
          if (typeof l.connectionClosedCallback === "function") {
            try {
              l.connectionClosedCallback(err);
            } catch (_) {
            }
          }
        });
        this.listeners = [];
      }
    };
  }
});

// node_modules/@nats-io/nats-core/lib/types.js
var require_types = __commonJS({
  "node_modules/@nats-io/nats-core/lib/types.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Empty = void 0;
    var encoders_1 = require_encoders();
    Object.defineProperty(exports, "Empty", { enumerable: true, get: function() {
      return encoders_1.Empty;
    } });
  }
});

// node_modules/@nats-io/nats-core/lib/bench.js
var require_bench = __commonJS({
  "node_modules/@nats-io/nats-core/lib/bench.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Bench = exports.Metric = void 0;
    exports.throughput = throughput;
    exports.msgThroughput = msgThroughput;
    exports.humanizeBytes = humanizeBytes;
    var types_1 = require_types();
    var nuid_1 = require_nuid2();
    var util_1 = require_util();
    var Metric = class {
      name;
      duration;
      date;
      payload;
      msgs;
      lang;
      version;
      bytes;
      asyncRequests;
      min;
      max;
      constructor(name, duration) {
        this.name = name;
        this.duration = duration;
        this.date = Date.now();
        this.payload = 0;
        this.msgs = 0;
        this.bytes = 0;
      }
      toString() {
        const sec = this.duration / 1e3;
        const mps = Math.round(this.msgs / sec);
        const label = this.asyncRequests ? "asyncRequests" : "";
        let minmax = "";
        if (this.max) {
          minmax = `${this.min}/${this.max}`;
        }
        return `${this.name}${label ? " [asyncRequests]" : ""} ${humanizeNumber(mps)} msgs/sec - [${sec.toFixed(2)} secs] ~ ${throughput(this.bytes, sec)} ${minmax}`;
      }
      toCsv() {
        return `"${this.name}",${new Date(this.date).toISOString()},${this.lang},${this.version},${this.msgs},${this.payload},${this.bytes},${this.duration},${this.asyncRequests ? this.asyncRequests : false}
`;
      }
      static header() {
        return `Test,Date,Lang,Version,Count,MsgPayload,Bytes,Millis,Async
`;
      }
    };
    exports.Metric = Metric;
    var Bench = class {
      nc;
      callbacks;
      msgs;
      size;
      subject;
      asyncRequests;
      pub;
      sub;
      req;
      rep;
      perf;
      payload;
      constructor(nc, opts = {
        msgs: 1e5,
        size: 128,
        subject: "",
        asyncRequests: false,
        pub: false,
        sub: false,
        req: false,
        rep: false
      }) {
        this.nc = nc;
        this.callbacks = opts.callbacks || false;
        this.msgs = opts.msgs || 0;
        this.size = opts.size || 0;
        this.subject = opts.subject || nuid_1.nuid.next();
        this.asyncRequests = opts.asyncRequests || false;
        this.pub = opts.pub || false;
        this.sub = opts.sub || false;
        this.req = opts.req || false;
        this.rep = opts.rep || false;
        this.perf = new util_1.Perf();
        this.payload = this.size ? new Uint8Array(this.size) : types_1.Empty;
        if (!this.pub && !this.sub && !this.req && !this.rep) {
          throw new Error("no options selected");
        }
      }
      async run() {
        this.nc.closed().then((err) => {
          if (err) {
            throw err;
          }
        });
        if (this.callbacks) {
          await this.runCallbacks();
        } else {
          await this.runAsync();
        }
        return this.processMetrics();
      }
      processMetrics() {
        const nc = this.nc;
        const { lang, version } = nc.protocol.transport;
        if (this.pub && this.sub) {
          this.perf.measure("pubsub", "pubStart", "subStop");
        }
        if (this.req && this.rep) {
          this.perf.measure("reqrep", "reqStart", "reqStop");
        }
        const measures = this.perf.getEntries();
        const pubsub = measures.find((m) => m.name === "pubsub");
        const reqrep = measures.find((m) => m.name === "reqrep");
        const req = measures.find((m) => m.name === "req");
        const rep = measures.find((m) => m.name === "rep");
        const pub = measures.find((m) => m.name === "pub");
        const sub = measures.find((m) => m.name === "sub");
        const stats = this.nc.stats();
        const metrics = [];
        if (pubsub) {
          const { name, duration } = pubsub;
          const m = new Metric(name, duration);
          m.msgs = this.msgs * 2;
          m.bytes = stats.inBytes + stats.outBytes;
          m.lang = lang;
          m.version = version;
          m.payload = this.payload.length;
          metrics.push(m);
        }
        if (reqrep) {
          const { name, duration } = reqrep;
          const m = new Metric(name, duration);
          m.msgs = this.msgs * 2;
          m.bytes = stats.inBytes + stats.outBytes;
          m.lang = lang;
          m.version = version;
          m.payload = this.payload.length;
          metrics.push(m);
        }
        if (pub) {
          const { name, duration } = pub;
          const m = new Metric(name, duration);
          m.msgs = this.msgs;
          m.bytes = stats.outBytes;
          m.lang = lang;
          m.version = version;
          m.payload = this.payload.length;
          metrics.push(m);
        }
        if (sub) {
          const { name, duration } = sub;
          const m = new Metric(name, duration);
          m.msgs = this.msgs;
          m.bytes = stats.inBytes;
          m.lang = lang;
          m.version = version;
          m.payload = this.payload.length;
          metrics.push(m);
        }
        if (rep) {
          const { name, duration } = rep;
          const m = new Metric(name, duration);
          m.msgs = this.msgs;
          m.bytes = stats.inBytes + stats.outBytes;
          m.lang = lang;
          m.version = version;
          m.payload = this.payload.length;
          metrics.push(m);
        }
        if (req) {
          const { name, duration } = req;
          const m = new Metric(name, duration);
          m.msgs = this.msgs;
          m.bytes = stats.inBytes + stats.outBytes;
          m.lang = lang;
          m.version = version;
          m.payload = this.payload.length;
          metrics.push(m);
        }
        return metrics;
      }
      async runCallbacks() {
        const jobs = [];
        if (this.sub) {
          const d = (0, util_1.deferred)();
          jobs.push(d);
          let i = 0;
          this.nc.subscribe(this.subject, {
            max: this.msgs,
            callback: () => {
              i++;
              if (i === 1) {
                this.perf.mark("subStart");
              }
              if (i === this.msgs) {
                this.perf.mark("subStop");
                this.perf.measure("sub", "subStart", "subStop");
                d.resolve();
              }
            }
          });
        }
        if (this.rep) {
          const d = (0, util_1.deferred)();
          jobs.push(d);
          let i = 0;
          this.nc.subscribe(this.subject, {
            max: this.msgs,
            callback: (_, m) => {
              m.respond(this.payload);
              i++;
              if (i === 1) {
                this.perf.mark("repStart");
              }
              if (i === this.msgs) {
                this.perf.mark("repStop");
                this.perf.measure("rep", "repStart", "repStop");
                d.resolve();
              }
            }
          });
        }
        if (this.pub) {
          const job = (async () => {
            this.perf.mark("pubStart");
            for (let i = 0; i < this.msgs; i++) {
              this.nc.publish(this.subject, this.payload);
            }
            await this.nc.flush();
            this.perf.mark("pubStop");
            this.perf.measure("pub", "pubStart", "pubStop");
          })();
          jobs.push(job);
        }
        if (this.req) {
          const job = (async () => {
            if (this.asyncRequests) {
              this.perf.mark("reqStart");
              const a = [];
              for (let i = 0; i < this.msgs; i++) {
                a.push(this.nc.request(this.subject, this.payload, { timeout: 2e4 }));
              }
              await Promise.all(a);
              this.perf.mark("reqStop");
              this.perf.measure("req", "reqStart", "reqStop");
            } else {
              this.perf.mark("reqStart");
              for (let i = 0; i < this.msgs; i++) {
                await this.nc.request(this.subject);
              }
              this.perf.mark("reqStop");
              this.perf.measure("req", "reqStart", "reqStop");
            }
          })();
          jobs.push(job);
        }
        await Promise.all(jobs);
      }
      async runAsync() {
        const jobs = [];
        if (this.rep) {
          let first = false;
          const sub = this.nc.subscribe(this.subject, { max: this.msgs });
          const job = (async () => {
            for await (const m of sub) {
              if (!first) {
                this.perf.mark("repStart");
                first = true;
              }
              m.respond(this.payload);
            }
            await this.nc.flush();
            this.perf.mark("repStop");
            this.perf.measure("rep", "repStart", "repStop");
          })();
          jobs.push(job);
        }
        if (this.sub) {
          let first = false;
          const sub = this.nc.subscribe(this.subject, { max: this.msgs });
          const job = (async () => {
            for await (const _m of sub) {
              if (!first) {
                this.perf.mark("subStart");
                first = true;
              }
            }
            this.perf.mark("subStop");
            this.perf.measure("sub", "subStart", "subStop");
          })();
          jobs.push(job);
        }
        if (this.pub) {
          const job = (async () => {
            this.perf.mark("pubStart");
            for (let i = 0; i < this.msgs; i++) {
              this.nc.publish(this.subject, this.payload);
            }
            await this.nc.flush();
            this.perf.mark("pubStop");
            this.perf.measure("pub", "pubStart", "pubStop");
          })();
          jobs.push(job);
        }
        if (this.req) {
          const job = (async () => {
            if (this.asyncRequests) {
              this.perf.mark("reqStart");
              const a = [];
              for (let i = 0; i < this.msgs; i++) {
                a.push(this.nc.request(this.subject, this.payload, { timeout: 2e4 }));
              }
              await Promise.all(a);
              this.perf.mark("reqStop");
              this.perf.measure("req", "reqStart", "reqStop");
            } else {
              this.perf.mark("reqStart");
              for (let i = 0; i < this.msgs; i++) {
                await this.nc.request(this.subject);
              }
              this.perf.mark("reqStop");
              this.perf.measure("req", "reqStart", "reqStop");
            }
          })();
          jobs.push(job);
        }
        await Promise.all(jobs);
      }
    };
    exports.Bench = Bench;
    function throughput(bytes, seconds) {
      return `${humanizeBytes(bytes / seconds)}/sec`;
    }
    function msgThroughput(msgs, seconds) {
      return `${Math.floor(msgs / seconds)} msgs/sec`;
    }
    function humanizeBytes(bytes, si = false) {
      const base = si ? 1e3 : 1024;
      const pre = si ? ["k", "M", "G", "T", "P", "E"] : ["K", "M", "G", "T", "P", "E"];
      const post = si ? "iB" : "B";
      if (bytes < base) {
        return `${bytes.toFixed(2)} ${post}`;
      }
      const exp = parseInt(Math.log(bytes) / Math.log(base) + "");
      const index = parseInt(exp - 1 + "");
      return `${(bytes / Math.pow(base, exp)).toFixed(2)} ${pre[index]}${post}`;
    }
    function humanizeNumber(n) {
      return n.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    }
  }
});

// node_modules/@nats-io/nats-core/lib/idleheartbeat_monitor.js
var require_idleheartbeat_monitor = __commonJS({
  "node_modules/@nats-io/nats-core/lib/idleheartbeat_monitor.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.IdleHeartbeatMonitor = void 0;
    var IdleHeartbeatMonitor = class {
      interval;
      maxOut;
      cancelAfter;
      timer;
      autoCancelTimer;
      last;
      missed;
      count;
      callback;
      /**
       * Constructor
       * @param interval in millis to check
       * @param cb a callback to report when heartbeats are missed
       * @param opts monitor options @see IdleHeartbeatOptions
       */
      constructor(interval, cb, opts = { maxOut: 2 }) {
        this.interval = interval;
        this.maxOut = opts?.maxOut || 2;
        this.cancelAfter = opts?.cancelAfter || 0;
        this.last = Date.now();
        this.missed = 0;
        this.count = 0;
        this.callback = cb;
        this._schedule();
      }
      /**
       * cancel monitoring
       */
      cancel() {
        if (this.autoCancelTimer) {
          clearTimeout(this.autoCancelTimer);
        }
        if (this.timer) {
          clearInterval(this.timer);
        }
        this.timer = 0;
        this.autoCancelTimer = 0;
        this.missed = 0;
      }
      /**
       * work signals that there was work performed
       */
      work() {
        this.last = Date.now();
        this.missed = 0;
      }
      /**
       * internal api to change the interval, cancelAfter and maxOut
       * @param interval
       * @param cancelAfter
       * @param maxOut
       */
      _change(interval, cancelAfter = 0, maxOut = 2) {
        this.interval = interval;
        this.maxOut = maxOut;
        this.cancelAfter = cancelAfter;
        this.restart();
      }
      /**
       * cancels and restarts the monitoring
       */
      restart() {
        this.cancel();
        this._schedule();
      }
      /**
       * internal api called to start monitoring
       */
      _schedule() {
        if (this.cancelAfter > 0) {
          this.autoCancelTimer = setTimeout(() => {
            this.cancel();
          }, this.cancelAfter);
        }
        this.timer = setInterval(() => {
          this.count++;
          if (Date.now() - this.last > this.interval) {
            this.missed++;
          }
          if (this.missed >= this.maxOut) {
            try {
              if (this.callback(this.missed) === true) {
                this.cancel();
              }
            } catch (err) {
              console.log(err);
            }
          }
        }, this.interval);
      }
    };
    exports.IdleHeartbeatMonitor = IdleHeartbeatMonitor;
  }
});

// node_modules/@nats-io/nats-core/lib/version.js
var require_version = __commonJS({
  "node_modules/@nats-io/nats-core/lib/version.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.version = void 0;
    exports.version = "3.3.0";
  }
});

// node_modules/@nats-io/nats-core/lib/ws_transport.js
var require_ws_transport = __commonJS({
  "node_modules/@nats-io/nats-core/lib/ws_transport.js"(exports) {
    "use strict";
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.WsTransport = void 0;
    exports.wsUrlParseFn = wsUrlParseFn;
    exports.wsconnect = wsconnect;
    var util_1 = require_util();
    var transport_1 = require_transport();
    var options_1 = require_options();
    var databuffer_1 = require_databuffer();
    var protocol_1 = require_protocol();
    var nats_1 = require_nats();
    var version_1 = require_version();
    var errors_1 = require_errors();
    var VERSION = version_1.version;
    var LANG = "nats.ws";
    var WsTransport = class {
      version;
      lang;
      closeError;
      connected;
      done;
      // @ts-ignore: expecting global WebSocket
      socket;
      options;
      socketClosed;
      encrypted;
      peeked;
      yields;
      signal;
      closedNotification;
      constructor() {
        this.version = VERSION;
        this.lang = LANG;
        this.connected = false;
        this.done = false;
        this.socketClosed = false;
        this.encrypted = false;
        this.peeked = false;
        this.yields = [];
        this.signal = (0, util_1.deferred)();
        this.closedNotification = (0, util_1.deferred)();
      }
      async connect(server, options) {
        const connected = false;
        const ok = (0, util_1.deferred)();
        this.options = options;
        const u = server.src;
        if (options.wsFactory) {
          const { socket, encrypted } = await options.wsFactory(server.src, options);
          this.socket = socket;
          this.encrypted = encrypted;
        } else {
          this.encrypted = u.indexOf("wss://") === 0;
          this.socket = new WebSocket(u);
        }
        this.socket.binaryType = "arraybuffer";
        this.socket.onopen = () => {
          if (this.done) {
            this._closed(new Error("aborted"));
          }
        };
        this.socket.onmessage = (me) => {
          if (this.done) {
            return;
          }
          this.yields.push(new Uint8Array(me.data));
          if (this.peeked) {
            this.signal.resolve();
            return;
          }
          const t = databuffer_1.DataBuffer.concat(...this.yields);
          const pm = (0, transport_1.extractProtocolMessage)(t);
          if (pm !== "") {
            const m = protocol_1.INFO.exec(pm);
            if (!m) {
              if (options.debug) {
                console.error("!!!", (0, util_1.render)(t));
              }
              ok.reject(new Error("unexpected response from server"));
              return;
            }
            try {
              const info = JSON.parse(m[1]);
              (0, options_1.checkOptions)(info, this.options);
              this.peeked = true;
              this.connected = true;
              this.signal.resolve();
              ok.resolve();
            } catch (err) {
              ok.reject(err);
              return;
            }
          }
        };
        this.socket.onclose = (evt) => {
          let reason;
          if (!evt.wasClean && evt.reason !== "") {
            reason = new Error(evt.reason);
          }
          this._closed(reason);
          this._cleanup();
        };
        this.socket.onerror = (e) => {
          if (this.done) {
            return;
          }
          const evt = e;
          const err = new errors_1.errors.ConnectionError(evt.message);
          if (!connected) {
            ok.reject(err);
          } else {
            this._closed(err);
          }
          this._cleanup();
        };
        return ok;
      }
      _cleanup() {
        if (this.socketClosed === false) {
          this.socketClosed = true;
          this.socket.onopen = null;
          this.socket.onmessage = null;
          this.socket.onerror = null;
          this.socket.onclose = null;
          this.closedNotification.resolve(this.closeError);
        }
      }
      disconnect() {
        this._closed(void 0, true);
      }
      async _closed(err, _internal = true) {
        if (this.done) {
          try {
            this.socket.close();
          } catch (_) {
          }
          return;
        }
        this.closeError = err;
        if (!err) {
          while (!this.socketClosed && this.socket.bufferedAmount > 0) {
            await (0, util_1.delay)(100);
          }
        }
        this.done = true;
        try {
          this.socket.close();
        } catch (_) {
        }
        return this.closedNotification;
      }
      get isClosed() {
        return this.done;
      }
      [Symbol.asyncIterator]() {
        return this.iterate();
      }
      async *iterate() {
        while (true) {
          if (this.done) {
            return;
          }
          if (this.yields.length === 0) {
            await this.signal;
          }
          const yields = this.yields;
          this.yields = [];
          for (let i = 0; i < yields.length; i++) {
            if (this.options.debug) {
              console.info(`> ${(0, util_1.render)(yields[i])}`);
            }
            yield yields[i];
          }
          if (this.done) {
            break;
          } else if (this.yields.length === 0) {
            yields.length = 0;
            this.yields = yields;
            this.signal = (0, util_1.deferred)();
          }
        }
      }
      isEncrypted() {
        return this.connected && this.encrypted;
      }
      send(frame) {
        if (this.done) {
          return;
        }
        try {
          this.socket.send(frame.buffer);
          if (this.options.debug) {
            console.info(`< ${(0, util_1.render)(frame)}`);
          }
          return;
        } catch (err) {
          if (this.options.debug) {
            console.error(`!!! ${(0, util_1.render)(frame)}: ${err}`);
          }
        }
      }
      close(err) {
        return this._closed(err, false);
      }
      closed() {
        return this.closedNotification;
      }
      // this is to allow a force discard on a connection
      // if the connection fails during the handshake protocol.
      // Firefox for example, will keep connections going,
      // so eventually if it succeeds, the client will have
      // an additional transport running. With this
      discard() {
        this.socket?.close();
      }
    };
    exports.WsTransport = WsTransport;
    function wsUrlParseFn(u, encrypted) {
      const ut = /^(.*:\/\/)(.*)/;
      if (!ut.test(u)) {
        if (typeof encrypted === "boolean") {
          u = `${encrypted === true ? "https" : "http"}://${u}`;
        } else {
          u = `https://${u}`;
        }
      }
      let url = new URL(u);
      const srcProto = url.protocol.toLowerCase();
      if (srcProto === "ws:") {
        encrypted = false;
      }
      if (srcProto === "wss:") {
        encrypted = true;
      }
      if (srcProto !== "https:" && srcProto !== "http") {
        u = u.replace(/^(.*:\/\/)(.*)/gm, "$2");
        url = new URL(`http://${u}`);
      }
      let protocol;
      let port;
      const host = url.hostname;
      const path = url.pathname;
      const search = url.search || "";
      switch (srcProto) {
        case "http:":
        case "ws:":
        case "nats:":
          port = url.port || "80";
          protocol = "ws:";
          break;
        case "https:":
        case "wss:":
        case "tls:":
          port = url.port || "443";
          protocol = "wss:";
          break;
        default:
          port = url.port || encrypted === true ? "443" : "80";
          protocol = encrypted === true ? "wss:" : "ws:";
          break;
      }
      return `${protocol}//${host}:${port}${path}${search}`;
    }
    function wsconnect(opts = {}) {
      (0, transport_1.setTransportFactory)({
        defaultPort: 443,
        urlParseFn: wsUrlParseFn,
        factory: () => {
          if (opts.tls) {
            throw errors_1.InvalidArgumentError.format("tls", "is not configurable on w3c websocket connections");
          }
          return new WsTransport();
        }
      });
      return nats_1.NatsConnectionImpl.connect(opts);
    }
  }
});

// node_modules/@nats-io/nats-core/lib/internal_mod.js
var require_internal_mod = __commonJS({
  "node_modules/@nats-io/nats-core/lib/internal_mod.js"(exports) {
    "use strict";
    var __createBinding = exports && exports.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports && exports.__exportStar || function(m, exports2) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports2, p)) __createBinding(exports2, m, p);
    };
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.Metric = exports.Bench = exports.writeAll = exports.readAll = exports.MAX_SIZE = exports.DenoBuffer = exports.State = exports.Parser = exports.Kind = exports.describe = exports.QueuedIteratorImpl = exports.usernamePasswordAuthenticator = exports.tokenAuthenticator = exports.nkeyAuthenticator = exports.jwtAuthenticator = exports.credsAuthenticator = exports.RequestOne = exports.parseOptions = exports.hasWsProtocol = exports.defaultOptions = exports.DEFAULT_MAX_RECONNECT_ATTEMPTS = exports.checkUnsupportedOption = exports.checkOptions = exports.buildAuthenticator = exports.DataBuffer = exports.MuxSubscription = exports.Heartbeat = exports.MsgHdrsImpl = exports.headers = exports.canonicalMIMEHeaderKey = exports.timeout = exports.SimpleMutex = exports.render = exports.nanos = exports.millis = exports.extend = exports.delay = exports.deferred = exports.deadline = exports.collect = exports.backoff = exports.ProtocolHandler = exports.INFO = exports.Connect = exports.setTransportFactory = exports.getResolveFn = exports.MsgImpl = exports.nuid = exports.Nuid = exports.NatsConnectionImpl = void 0;
    exports.UserAuthenticationExpiredError = exports.TimeoutError = exports.RequestError = exports.ProtocolError = exports.PermissionViolationError = exports.NoRespondersError = exports.InvalidSubjectError = exports.InvalidOperationError = exports.InvalidArgumentError = exports.errors = exports.DrainingConnectionError = exports.ConnectionError = exports.ClosedConnectionError = exports.AuthorizationError = exports.wsUrlParseFn = exports.wsconnect = exports.Servers = exports.isIPV4OrHostname = exports.IdleHeartbeatMonitor = exports.Subscriptions = exports.SubscriptionImpl = exports.syncIterator = exports.Match = exports.createInbox = exports.protoLen = exports.extractProtocolMessage = exports.Empty = exports.parseSemVer = exports.Features = exports.Feature = exports.compare = exports.parseIP = exports.isIP = exports.ipV4 = exports.TE = exports.TD = void 0;
    var nats_1 = require_nats();
    Object.defineProperty(exports, "NatsConnectionImpl", { enumerable: true, get: function() {
      return nats_1.NatsConnectionImpl;
    } });
    var nuid_1 = require_nuid2();
    Object.defineProperty(exports, "Nuid", { enumerable: true, get: function() {
      return nuid_1.Nuid;
    } });
    Object.defineProperty(exports, "nuid", { enumerable: true, get: function() {
      return nuid_1.nuid;
    } });
    var msg_1 = require_msg();
    Object.defineProperty(exports, "MsgImpl", { enumerable: true, get: function() {
      return msg_1.MsgImpl;
    } });
    var transport_1 = require_transport();
    Object.defineProperty(exports, "getResolveFn", { enumerable: true, get: function() {
      return transport_1.getResolveFn;
    } });
    Object.defineProperty(exports, "setTransportFactory", { enumerable: true, get: function() {
      return transport_1.setTransportFactory;
    } });
    var protocol_1 = require_protocol();
    Object.defineProperty(exports, "Connect", { enumerable: true, get: function() {
      return protocol_1.Connect;
    } });
    Object.defineProperty(exports, "INFO", { enumerable: true, get: function() {
      return protocol_1.INFO;
    } });
    Object.defineProperty(exports, "ProtocolHandler", { enumerable: true, get: function() {
      return protocol_1.ProtocolHandler;
    } });
    var util_1 = require_util();
    Object.defineProperty(exports, "backoff", { enumerable: true, get: function() {
      return util_1.backoff;
    } });
    Object.defineProperty(exports, "collect", { enumerable: true, get: function() {
      return util_1.collect;
    } });
    Object.defineProperty(exports, "deadline", { enumerable: true, get: function() {
      return util_1.deadline;
    } });
    Object.defineProperty(exports, "deferred", { enumerable: true, get: function() {
      return util_1.deferred;
    } });
    Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
      return util_1.delay;
    } });
    Object.defineProperty(exports, "extend", { enumerable: true, get: function() {
      return util_1.extend;
    } });
    Object.defineProperty(exports, "millis", { enumerable: true, get: function() {
      return util_1.millis;
    } });
    Object.defineProperty(exports, "nanos", { enumerable: true, get: function() {
      return util_1.nanos;
    } });
    Object.defineProperty(exports, "render", { enumerable: true, get: function() {
      return util_1.render;
    } });
    Object.defineProperty(exports, "SimpleMutex", { enumerable: true, get: function() {
      return util_1.SimpleMutex;
    } });
    Object.defineProperty(exports, "timeout", { enumerable: true, get: function() {
      return util_1.timeout;
    } });
    var headers_1 = require_headers();
    Object.defineProperty(exports, "canonicalMIMEHeaderKey", { enumerable: true, get: function() {
      return headers_1.canonicalMIMEHeaderKey;
    } });
    Object.defineProperty(exports, "headers", { enumerable: true, get: function() {
      return headers_1.headers;
    } });
    Object.defineProperty(exports, "MsgHdrsImpl", { enumerable: true, get: function() {
      return headers_1.MsgHdrsImpl;
    } });
    var heartbeats_1 = require_heartbeats();
    Object.defineProperty(exports, "Heartbeat", { enumerable: true, get: function() {
      return heartbeats_1.Heartbeat;
    } });
    var muxsubscription_1 = require_muxsubscription();
    Object.defineProperty(exports, "MuxSubscription", { enumerable: true, get: function() {
      return muxsubscription_1.MuxSubscription;
    } });
    var databuffer_1 = require_databuffer();
    Object.defineProperty(exports, "DataBuffer", { enumerable: true, get: function() {
      return databuffer_1.DataBuffer;
    } });
    var options_1 = require_options();
    Object.defineProperty(exports, "buildAuthenticator", { enumerable: true, get: function() {
      return options_1.buildAuthenticator;
    } });
    Object.defineProperty(exports, "checkOptions", { enumerable: true, get: function() {
      return options_1.checkOptions;
    } });
    Object.defineProperty(exports, "checkUnsupportedOption", { enumerable: true, get: function() {
      return options_1.checkUnsupportedOption;
    } });
    Object.defineProperty(exports, "DEFAULT_MAX_RECONNECT_ATTEMPTS", { enumerable: true, get: function() {
      return options_1.DEFAULT_MAX_RECONNECT_ATTEMPTS;
    } });
    Object.defineProperty(exports, "defaultOptions", { enumerable: true, get: function() {
      return options_1.defaultOptions;
    } });
    Object.defineProperty(exports, "hasWsProtocol", { enumerable: true, get: function() {
      return options_1.hasWsProtocol;
    } });
    Object.defineProperty(exports, "parseOptions", { enumerable: true, get: function() {
      return options_1.parseOptions;
    } });
    var request_1 = require_request();
    Object.defineProperty(exports, "RequestOne", { enumerable: true, get: function() {
      return request_1.RequestOne;
    } });
    var authenticator_1 = require_authenticator();
    Object.defineProperty(exports, "credsAuthenticator", { enumerable: true, get: function() {
      return authenticator_1.credsAuthenticator;
    } });
    Object.defineProperty(exports, "jwtAuthenticator", { enumerable: true, get: function() {
      return authenticator_1.jwtAuthenticator;
    } });
    Object.defineProperty(exports, "nkeyAuthenticator", { enumerable: true, get: function() {
      return authenticator_1.nkeyAuthenticator;
    } });
    Object.defineProperty(exports, "tokenAuthenticator", { enumerable: true, get: function() {
      return authenticator_1.tokenAuthenticator;
    } });
    Object.defineProperty(exports, "usernamePasswordAuthenticator", { enumerable: true, get: function() {
      return authenticator_1.usernamePasswordAuthenticator;
    } });
    __exportStar(require_nkeys(), exports);
    var queued_iterator_1 = require_queued_iterator();
    Object.defineProperty(exports, "QueuedIteratorImpl", { enumerable: true, get: function() {
      return queued_iterator_1.QueuedIteratorImpl;
    } });
    var parser_1 = require_parser();
    Object.defineProperty(exports, "describe", { enumerable: true, get: function() {
      return parser_1.describe;
    } });
    Object.defineProperty(exports, "Kind", { enumerable: true, get: function() {
      return parser_1.Kind;
    } });
    Object.defineProperty(exports, "Parser", { enumerable: true, get: function() {
      return parser_1.Parser;
    } });
    Object.defineProperty(exports, "State", { enumerable: true, get: function() {
      return parser_1.State;
    } });
    var denobuffer_1 = require_denobuffer();
    Object.defineProperty(exports, "DenoBuffer", { enumerable: true, get: function() {
      return denobuffer_1.DenoBuffer;
    } });
    Object.defineProperty(exports, "MAX_SIZE", { enumerable: true, get: function() {
      return denobuffer_1.MAX_SIZE;
    } });
    Object.defineProperty(exports, "readAll", { enumerable: true, get: function() {
      return denobuffer_1.readAll;
    } });
    Object.defineProperty(exports, "writeAll", { enumerable: true, get: function() {
      return denobuffer_1.writeAll;
    } });
    var bench_1 = require_bench();
    Object.defineProperty(exports, "Bench", { enumerable: true, get: function() {
      return bench_1.Bench;
    } });
    Object.defineProperty(exports, "Metric", { enumerable: true, get: function() {
      return bench_1.Metric;
    } });
    var encoders_1 = require_encoders();
    Object.defineProperty(exports, "TD", { enumerable: true, get: function() {
      return encoders_1.TD;
    } });
    Object.defineProperty(exports, "TE", { enumerable: true, get: function() {
      return encoders_1.TE;
    } });
    var ipparser_1 = require_ipparser();
    Object.defineProperty(exports, "ipV4", { enumerable: true, get: function() {
      return ipparser_1.ipV4;
    } });
    Object.defineProperty(exports, "isIP", { enumerable: true, get: function() {
      return ipparser_1.isIP;
    } });
    Object.defineProperty(exports, "parseIP", { enumerable: true, get: function() {
      return ipparser_1.parseIP;
    } });
    var semver_1 = require_semver();
    Object.defineProperty(exports, "compare", { enumerable: true, get: function() {
      return semver_1.compare;
    } });
    Object.defineProperty(exports, "Feature", { enumerable: true, get: function() {
      return semver_1.Feature;
    } });
    Object.defineProperty(exports, "Features", { enumerable: true, get: function() {
      return semver_1.Features;
    } });
    Object.defineProperty(exports, "parseSemVer", { enumerable: true, get: function() {
      return semver_1.parseSemVer;
    } });
    var types_1 = require_types();
    Object.defineProperty(exports, "Empty", { enumerable: true, get: function() {
      return types_1.Empty;
    } });
    var transport_2 = require_transport();
    Object.defineProperty(exports, "extractProtocolMessage", { enumerable: true, get: function() {
      return transport_2.extractProtocolMessage;
    } });
    Object.defineProperty(exports, "protoLen", { enumerable: true, get: function() {
      return transport_2.protoLen;
    } });
    var core_1 = require_core();
    Object.defineProperty(exports, "createInbox", { enumerable: true, get: function() {
      return core_1.createInbox;
    } });
    Object.defineProperty(exports, "Match", { enumerable: true, get: function() {
      return core_1.Match;
    } });
    Object.defineProperty(exports, "syncIterator", { enumerable: true, get: function() {
      return core_1.syncIterator;
    } });
    var protocol_2 = require_protocol();
    Object.defineProperty(exports, "SubscriptionImpl", { enumerable: true, get: function() {
      return protocol_2.SubscriptionImpl;
    } });
    Object.defineProperty(exports, "Subscriptions", { enumerable: true, get: function() {
      return protocol_2.Subscriptions;
    } });
    var idleheartbeat_monitor_1 = require_idleheartbeat_monitor();
    Object.defineProperty(exports, "IdleHeartbeatMonitor", { enumerable: true, get: function() {
      return idleheartbeat_monitor_1.IdleHeartbeatMonitor;
    } });
    var servers_1 = require_servers();
    Object.defineProperty(exports, "isIPV4OrHostname", { enumerable: true, get: function() {
      return servers_1.isIPV4OrHostname;
    } });
    Object.defineProperty(exports, "Servers", { enumerable: true, get: function() {
      return servers_1.Servers;
    } });
    var ws_transport_1 = require_ws_transport();
    Object.defineProperty(exports, "wsconnect", { enumerable: true, get: function() {
      return ws_transport_1.wsconnect;
    } });
    Object.defineProperty(exports, "wsUrlParseFn", { enumerable: true, get: function() {
      return ws_transport_1.wsUrlParseFn;
    } });
    var errors_1 = require_errors();
    Object.defineProperty(exports, "AuthorizationError", { enumerable: true, get: function() {
      return errors_1.AuthorizationError;
    } });
    Object.defineProperty(exports, "ClosedConnectionError", { enumerable: true, get: function() {
      return errors_1.ClosedConnectionError;
    } });
    Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function() {
      return errors_1.ConnectionError;
    } });
    Object.defineProperty(exports, "DrainingConnectionError", { enumerable: true, get: function() {
      return errors_1.DrainingConnectionError;
    } });
    Object.defineProperty(exports, "errors", { enumerable: true, get: function() {
      return errors_1.errors;
    } });
    Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function() {
      return errors_1.InvalidArgumentError;
    } });
    Object.defineProperty(exports, "InvalidOperationError", { enumerable: true, get: function() {
      return errors_1.InvalidOperationError;
    } });
    Object.defineProperty(exports, "InvalidSubjectError", { enumerable: true, get: function() {
      return errors_1.InvalidSubjectError;
    } });
    Object.defineProperty(exports, "NoRespondersError", { enumerable: true, get: function() {
      return errors_1.NoRespondersError;
    } });
    Object.defineProperty(exports, "PermissionViolationError", { enumerable: true, get: function() {
      return errors_1.PermissionViolationError;
    } });
    Object.defineProperty(exports, "ProtocolError", { enumerable: true, get: function() {
      return errors_1.ProtocolError;
    } });
    Object.defineProperty(exports, "RequestError", { enumerable: true, get: function() {
      return errors_1.RequestError;
    } });
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return errors_1.TimeoutError;
    } });
    Object.defineProperty(exports, "UserAuthenticationExpiredError", { enumerable: true, get: function() {
      return errors_1.UserAuthenticationExpiredError;
    } });
  }
});

// node_modules/@nats-io/nats-core/lib/mod.js
var require_mod2 = __commonJS({
  "node_modules/@nats-io/nats-core/lib/mod.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    exports.wsconnect = exports.usernamePasswordAuthenticator = exports.UserAuthenticationExpiredError = exports.tokenAuthenticator = exports.TimeoutError = exports.syncIterator = exports.RequestError = exports.ProtocolError = exports.PermissionViolationError = exports.nuid = exports.Nuid = exports.NoRespondersError = exports.nkeys = exports.nkeyAuthenticator = exports.nanos = exports.MsgHdrsImpl = exports.millis = exports.Metric = exports.Match = exports.jwtAuthenticator = exports.InvalidSubjectError = exports.InvalidOperationError = exports.InvalidArgumentError = exports.headers = exports.hasWsProtocol = exports.errors = exports.Empty = exports.DrainingConnectionError = exports.delay = exports.deferred = exports.deadline = exports.credsAuthenticator = exports.createInbox = exports.ConnectionError = exports.ClosedConnectionError = exports.canonicalMIMEHeaderKey = exports.buildAuthenticator = exports.Bench = exports.backoff = exports.AuthorizationError = void 0;
    var internal_mod_1 = require_internal_mod();
    Object.defineProperty(exports, "AuthorizationError", { enumerable: true, get: function() {
      return internal_mod_1.AuthorizationError;
    } });
    Object.defineProperty(exports, "backoff", { enumerable: true, get: function() {
      return internal_mod_1.backoff;
    } });
    Object.defineProperty(exports, "Bench", { enumerable: true, get: function() {
      return internal_mod_1.Bench;
    } });
    Object.defineProperty(exports, "buildAuthenticator", { enumerable: true, get: function() {
      return internal_mod_1.buildAuthenticator;
    } });
    Object.defineProperty(exports, "canonicalMIMEHeaderKey", { enumerable: true, get: function() {
      return internal_mod_1.canonicalMIMEHeaderKey;
    } });
    Object.defineProperty(exports, "ClosedConnectionError", { enumerable: true, get: function() {
      return internal_mod_1.ClosedConnectionError;
    } });
    Object.defineProperty(exports, "ConnectionError", { enumerable: true, get: function() {
      return internal_mod_1.ConnectionError;
    } });
    Object.defineProperty(exports, "createInbox", { enumerable: true, get: function() {
      return internal_mod_1.createInbox;
    } });
    Object.defineProperty(exports, "credsAuthenticator", { enumerable: true, get: function() {
      return internal_mod_1.credsAuthenticator;
    } });
    Object.defineProperty(exports, "deadline", { enumerable: true, get: function() {
      return internal_mod_1.deadline;
    } });
    Object.defineProperty(exports, "deferred", { enumerable: true, get: function() {
      return internal_mod_1.deferred;
    } });
    Object.defineProperty(exports, "delay", { enumerable: true, get: function() {
      return internal_mod_1.delay;
    } });
    Object.defineProperty(exports, "DrainingConnectionError", { enumerable: true, get: function() {
      return internal_mod_1.DrainingConnectionError;
    } });
    Object.defineProperty(exports, "Empty", { enumerable: true, get: function() {
      return internal_mod_1.Empty;
    } });
    Object.defineProperty(exports, "errors", { enumerable: true, get: function() {
      return internal_mod_1.errors;
    } });
    Object.defineProperty(exports, "hasWsProtocol", { enumerable: true, get: function() {
      return internal_mod_1.hasWsProtocol;
    } });
    Object.defineProperty(exports, "headers", { enumerable: true, get: function() {
      return internal_mod_1.headers;
    } });
    Object.defineProperty(exports, "InvalidArgumentError", { enumerable: true, get: function() {
      return internal_mod_1.InvalidArgumentError;
    } });
    Object.defineProperty(exports, "InvalidOperationError", { enumerable: true, get: function() {
      return internal_mod_1.InvalidOperationError;
    } });
    Object.defineProperty(exports, "InvalidSubjectError", { enumerable: true, get: function() {
      return internal_mod_1.InvalidSubjectError;
    } });
    Object.defineProperty(exports, "jwtAuthenticator", { enumerable: true, get: function() {
      return internal_mod_1.jwtAuthenticator;
    } });
    Object.defineProperty(exports, "Match", { enumerable: true, get: function() {
      return internal_mod_1.Match;
    } });
    Object.defineProperty(exports, "Metric", { enumerable: true, get: function() {
      return internal_mod_1.Metric;
    } });
    Object.defineProperty(exports, "millis", { enumerable: true, get: function() {
      return internal_mod_1.millis;
    } });
    Object.defineProperty(exports, "MsgHdrsImpl", { enumerable: true, get: function() {
      return internal_mod_1.MsgHdrsImpl;
    } });
    Object.defineProperty(exports, "nanos", { enumerable: true, get: function() {
      return internal_mod_1.nanos;
    } });
    Object.defineProperty(exports, "nkeyAuthenticator", { enumerable: true, get: function() {
      return internal_mod_1.nkeyAuthenticator;
    } });
    Object.defineProperty(exports, "nkeys", { enumerable: true, get: function() {
      return internal_mod_1.nkeys;
    } });
    Object.defineProperty(exports, "NoRespondersError", { enumerable: true, get: function() {
      return internal_mod_1.NoRespondersError;
    } });
    Object.defineProperty(exports, "Nuid", { enumerable: true, get: function() {
      return internal_mod_1.Nuid;
    } });
    Object.defineProperty(exports, "nuid", { enumerable: true, get: function() {
      return internal_mod_1.nuid;
    } });
    Object.defineProperty(exports, "PermissionViolationError", { enumerable: true, get: function() {
      return internal_mod_1.PermissionViolationError;
    } });
    Object.defineProperty(exports, "ProtocolError", { enumerable: true, get: function() {
      return internal_mod_1.ProtocolError;
    } });
    Object.defineProperty(exports, "RequestError", { enumerable: true, get: function() {
      return internal_mod_1.RequestError;
    } });
    Object.defineProperty(exports, "syncIterator", { enumerable: true, get: function() {
      return internal_mod_1.syncIterator;
    } });
    Object.defineProperty(exports, "TimeoutError", { enumerable: true, get: function() {
      return internal_mod_1.TimeoutError;
    } });
    Object.defineProperty(exports, "tokenAuthenticator", { enumerable: true, get: function() {
      return internal_mod_1.tokenAuthenticator;
    } });
    Object.defineProperty(exports, "UserAuthenticationExpiredError", { enumerable: true, get: function() {
      return internal_mod_1.UserAuthenticationExpiredError;
    } });
    Object.defineProperty(exports, "usernamePasswordAuthenticator", { enumerable: true, get: function() {
      return internal_mod_1.usernamePasswordAuthenticator;
    } });
    Object.defineProperty(exports, "wsconnect", { enumerable: true, get: function() {
      return internal_mod_1.wsconnect;
    } });
  }
});
export default require_mod2();
//# sourceMappingURL=@nats-io_nats-core.js.map
